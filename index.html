<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Order of the Gods - Dungeon of Mount Olympus</title>
  <!-- Google Fonts for Greek Mythological Styling -->
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #000;
      font-family: Arial, sans-serif;
      overflow: hidden; /* Prevent scrollbars */
      width: 100vw;
      height: 100vh;
    }
    canvas {
      display: block;
      background: #1a1a1a;
      cursor: none; /* Hide mouse cursor */
      width: 100vw;
      height: 100vh;
    }
    .mobile-warning {
      display: none;
      color: white;
      text-align: center;
      padding: 20px;
      font-size: 24px;
    }
    /* Block mobile and small screens - updated for fullscreen */
    @media (max-width: 1200px), (max-height: 600px) {
      canvas { display: none !important; }
      .mobile-warning { display: block !important; }
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div class="mobile-warning">
    <h2>üñ•Ô∏è Laptop + Keyboard Required</h2>
    <p>This game requires a laptop or desktop computer with keyboard controls.</p>
    <p>WASD keys required for movement.</p>
  </div>

  <script>
    // =============================================================================
    // ORDER OF THE GODS - PHASE 1 IMPLEMENTATION
    // =============================================================================
    
    console.log("üèõÔ∏è Order of the Gods - Starting Phase 1...");
    
    // Get canvas and context - FULLSCREEN SETUP
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas to full screen dimensions - SIMPLE AND WORKING
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Optimize image rendering for crisp display
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    
    console.log(`üñ•Ô∏è Simple canvas: ${canvas.width}x${canvas.height} - positioning preserved`);
    
    // Verify canvas support
    if (!ctx) {
      alert('Your browser does not support Canvas. Please use Chrome, Firefox, or Safari.');
      throw new Error('Canvas not supported');
    }
    
    console.log(`‚úÖ Canvas initialized: ${canvas.width}x${canvas.height}`);
    
    // =============================================================================
    // CONSTANTS & CONFIGURATION
    // =============================================================================
    
    // EXACT KITCHEN LAYOUT COORDINATES (DO NOT CHANGE)
    const KITCHEN = {
      BOUNDS: {
        LEFT: 280,    // Kitchen area starts further right to make room for customers
        RIGHT: window.innerWidth - 80, // Dynamic based on screen width 
        TOP: 80,
        BOTTOM: window.innerHeight - 80 // Dynamic based on screen height
      },
      CUSTOMER_AREA: {
        LEFT: 50,     // Customer walking/waiting area
        RIGHT: 270,    
        TOP: 160,     // Below header (120px + sprite height buffer)
        BOTTOM: window.innerHeight - 80, // Dynamic based on screen height
        QUEUE_X: 200, // Where customers line up
        ENTRANCE_Y: 260, // Where customers enter from (adjusted for 144px sprites)
        EXIT_Y: window.innerHeight - 100   // Where customers exit to (near bottom)
      },
      POSITIONS: {
        COUNTER: { x: Math.max(640, window.innerWidth * 0.5), y: 200 },     // Centered delivery counter (responsive)
        TABLE: { x: Math.max(640, window.innerWidth * 0.5), y: Math.max(360, window.innerHeight * 0.4) },       // Central plate assembly (responsive)
        TRASH: { x: window.innerWidth - 150, y: window.innerHeight - 150 }, // Trash bin - bottom right corner (responsive)
        OVEN: { x: 450, y: 280 },         // Divine cooking oven (left side)
        CUTTING_BOARD: { x: window.innerWidth - 250, y: 320 }, // Ancient cutting board (right side, responsive)
        BINS: {
          bread: { x: 360, y: 260 },     // Left side bins
          tomato: { x: 360, y: 460 },    
          cheese: { x: window.innerWidth - 160, y: 260 },   // Right side bins (responsive)
          meat: { x: window.innerWidth - 160, y: 460 },     
          egg: { x: Math.max(530, window.innerWidth * 0.4), y: window.innerHeight - 180 },       // Bottom bins (responsive)
          pepper: { x: Math.max(750, window.innerWidth * 0.5), y: window.innerHeight - 180 },
          bacon: { x: Math.max(850, window.innerWidth * 0.55), y: window.innerHeight - 180 },    // New ingredients!
          avocado: { x: Math.max(950, window.innerWidth * 0.6), y: window.innerHeight - 180 }
        }
      },
      ZONES: {
        TABLE_RADIUS: 90,        // Distance to interact with table
        BIN_RADIUS: 60,          // Distance to interact with bins
        TRASH_RADIUS: 50,        // Distance to interact with trash
        OVEN_RADIUS: 70,         // Distance to interact with oven
        CUTTING_RADIUS: 70,      // Distance to interact with cutting board
        COUNTER_WIDTH: 360,      // Width of delivery zone
        COUNTER_HEIGHT: 40,      // Height of delivery zone
        INTERACTION_BUFFER: 8    // Extra pixels for generous collision
      }
    };
    
    // Game configuration
    const CONFIG = {
      PLAYER_SPEED: 5,           // Pixels per frame (300 px/sec at 60fps)
      PLAYER_SIZE: 32,           // Player square size
      MAX_PLATE_SIZE: 5,         // Maximum ingredients on plate
      MAX_CARRY: 1,              // Can only carry one ingredient
      
      // Timing
      LEVEL_1_TIME: 22,          // Seconds per riddle (level 1)
      LEVEL_2_TIME: 18,          // Seconds per riddle (level 2)
      LEVEL_3_TIME: 15,          // Seconds per riddle (level 3)
      
      // Progression
      LEVEL_2_SCORE: 10,         // Score needed for level 2
      LEVEL_3_SCORE: 20,         // Score needed for level 3
      WIN_SCORE: 30,             // Score needed to win
      
      // Visual
      COLORS: {
        PLAYER: '#FFD700',       // Gold
        BREAD: '#DEB887',        // Burlywood
        TOMATO: '#FF6347',       // Tomato red
        CHEESE: '#FFD700',       // Gold
        MEAT: '#8B0000',         // Dark red
        EGG: '#FFFACD',          // Lemon chiffon
        PEPPER: '#FF4500',       // Orange red
        TABLE: '#8B4513',        // Saddle brown
        COUNTER: '#696969',      // Dim gray
        WALL: '#4a4a4a',         // Gray
        FLOOR: '#2a2a2a'         // Dark gray
      }
    };
    
    console.log("‚úÖ Configuration loaded");
    
    // =============================================================================
    // ASSET LOADING SYSTEM (PHASE 3)
    // =============================================================================
    
    // Asset mapping and loading
    const ASSETS = {
      ingredients: {},
      customers: {},
      ui: {},
      loaded: false,
      totalAssets: 0,
      loadedAssets: 0
    };
    
    // Asset file mapping
    const ASSET_FILES = {
      ingredients: {
        bread: 'assets/bread.png',
        tomato: 'assets/tomato.png', 
        cheese: 'assets/cheese.png',
        meat: 'assets/meat.png',
        egg: 'assets/egg.png',
        pepper: 'assets/pepper.png',
        bacon: 'assets/bacon.png',     // New ingredient for complex recipes!
        avocado: 'assets/avocado.png'  // New ingredient for complex recipes!
      },
      customers: {
        medusa: 'assets/medusa.png',
        minotaur: 'assets/minotaur.png',
        hermes: 'assets/hermes.png',
        sphinx: 'assets/sphinx.png',
        pegasus: 'assets/pegasus.png',
        poseidon: 'assets/poseidon.png',
        ghost: 'assets/restless-spirit.png',
        zeus: 'assets/zeus.png',       // Lord of Olympus!
        hera: 'assets/hera.png',       // Queen of the gods!
        hydra: 'assets/hydra.png',     // Legendary beast!
        chimera: 'assets/chimera.png'  // Three-headed monster!
      },
      ui: {
        plate: 'assets/plate.png',
        crate: 'assets/crate.png'
      },
      kitchen: {
        oven: 'assets/oven.png',           // Divine cooking station!
        cuttingBoard: 'assets/cutting-board.png',  // Ancient cutting board!
        feastHall: 'assets/feast-hall.png'  // Background enhancement!
      },
      cutIngredients: {
        cut_tomato: 'assets/cut-tomato.png',
        cut_cheese: 'assets/cut-cheese.png',
        cut_meat: 'assets/cut-meat.png',
        cut_avocado: 'assets/cut-avocado.png',
        cut_pepper: 'assets/cut-pepper.png'
      },
      player: {
        character: 'assets/main-character.png'
      }
    };
    
    // Load image helper
    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          ASSETS.loadedAssets++;
          console.log(`‚úÖ Loaded: ${src} (${ASSETS.loadedAssets}/${ASSETS.totalAssets})`);
          resolve(img);
        };
        img.onerror = () => {
          ASSETS.loadedAssets++;
          console.log(`‚ùå Failed: ${src}`);
          reject(new Error(`Failed to load ${src}`));
        };
        img.src = src;
      });
    }
    
    // Load all assets
    async function loadAssets() {
      console.log('üé® Loading Phase 3 assets...');
      
      const loadPromises = [];
      
      // Count total assets
      Object.values(ASSET_FILES.ingredients).forEach(src => src && ASSETS.totalAssets++);
      Object.values(ASSET_FILES.customers).forEach(src => src && ASSETS.totalAssets++);
      Object.values(ASSET_FILES.ui).forEach(src => src && ASSETS.totalAssets++);
      Object.values(ASSET_FILES.kitchen).forEach(src => src && ASSETS.totalAssets++); // Add kitchen cooking stations
      Object.values(ASSET_FILES.cutIngredients).forEach(src => src && ASSETS.totalAssets++); // Add cut ingredient assets
      Object.values(ASSET_FILES.player).forEach(src => src && ASSETS.totalAssets++); // Add player assets to count
      
      // Load ingredient assets
      for (let [ingredient, src] of Object.entries(ASSET_FILES.ingredients)) {
        if (src) {
          loadPromises.push(
            loadImage(src).then(img => {
              ASSETS.ingredients[ingredient] = img;
            }).catch(() => {
              console.log(`‚ö†Ô∏è Using fallback for ${ingredient}`);
              ASSETS.ingredients[ingredient] = null;
            })
          );
        } else {
          ASSETS.ingredients[ingredient] = null; // Will use fallback rendering
        }
      }
      
      // Load customer assets
      for (let [customer, src] of Object.entries(ASSET_FILES.customers)) {
        if (src) {
          loadPromises.push(
            loadImage(src).then(img => {
              ASSETS.customers[customer] = img;
            }).catch(() => {
              ASSETS.customers[customer] = null;
            })
          );
        }
      }
      
      // Load UI assets
      for (let [ui, src] of Object.entries(ASSET_FILES.ui)) {
        if (src) {
          loadPromises.push(
            loadImage(src).then(img => {
              ASSETS.ui[ui] = img;
            }).catch(() => {
              ASSETS.ui[ui] = null;
            })
          );
        }
      }
      
      // Load kitchen assets (oven, etc.)
      for (let [kitchen, src] of Object.entries(ASSET_FILES.kitchen)) {
        if (src) {
          loadPromises.push(
            loadImage(src).then(img => {
              if (!ASSETS.kitchen) ASSETS.kitchen = {};
              ASSETS.kitchen[kitchen] = img;
              console.log(`‚úÖ Kitchen asset loaded: ${kitchen}`);
            }).catch(() => {
              if (!ASSETS.kitchen) ASSETS.kitchen = {};
              ASSETS.kitchen[kitchen] = null;
              console.log(`‚ùå Kitchen asset failed: ${kitchen}`);
            })
          );
        }
      }
      
      // Load cut ingredient assets
      for (let [cutItem, src] of Object.entries(ASSET_FILES.cutIngredients)) {
        if (src) {
          loadPromises.push(
            loadImage(src).then(img => {
              if (!ASSETS.cutIngredients) ASSETS.cutIngredients = {};
              ASSETS.cutIngredients[cutItem] = img;
              console.log(`‚úÖ Cut ingredient asset loaded: ${cutItem}`);
            }).catch(() => {
              if (!ASSETS.cutIngredients) ASSETS.cutIngredients = {};
              ASSETS.cutIngredients[cutItem] = null;
              console.log(`‚ùå Cut ingredient asset failed: ${cutItem}`);
            })
          );
        }
      }
      
      // Load player assets
      for (let [player, src] of Object.entries(ASSET_FILES.player)) {
        if (src) {
          loadPromises.push(
            loadImage(src).then(img => {
              if (!ASSETS.player) ASSETS.player = {};
              ASSETS.player[player] = img;
              console.log(`‚úÖ Player asset loaded: ${player}`);
            }).catch(() => {
              if (!ASSETS.player) ASSETS.player = {};
              ASSETS.player[player] = null;
              console.log(`‚ùå Player asset failed: ${player}`);
            })
          );
        }
      }
      
      // Wait for all assets to load
      await Promise.allSettled(loadPromises);
      
      ASSETS.loaded = true;
      console.log(`üé® Phase 3 assets loaded: ${ASSETS.loadedAssets}/${ASSETS.totalAssets}`);
      
      // Debug player character loading
      if (ASSETS.player?.character) {
        console.log('‚úÖ Player character sprite loaded successfully!');
      } else {
        console.log('‚ùå Player character sprite failed to load - will use fallback square');
      }
      
      return ASSETS.loaded;
    }
    
    console.log("‚úÖ Asset system initialized");
    
    // Global render quality optimization
    function ensureRenderQuality() {
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      // Ensure crisp pixel-perfect rendering
      ctx.textRenderingOptimization = 'optimizeQuality';
    }
    
    // =============================================================================
    // AUDIO SYSTEM (PHASE 3)
    // =============================================================================
    
    // Audio context and sound effects
    const AUDIO = {
      context: null,
      enabled: true,
      sounds: {},
      
      // Initialize audio context
      init() {
        try {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
          console.log('üîä Audio system initialized');
        } catch (error) {
          console.log('‚ö†Ô∏è Audio not supported');
          this.enabled = false;
        }
      },
      
      // Create a simple beep sound
      createBeep(frequency, duration, type = 'sine') {
        if (!this.enabled || !this.context) return;
        
        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);
        
        oscillator.frequency.value = frequency;
        oscillator.type = type;
        
        gainNode.gain.setValueAtTime(0.1, this.context.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);
        
        oscillator.start(this.context.currentTime);
        oscillator.stop(this.context.currentTime + duration);
      },
      
      // Play different sound effects
      playPickup() {
        this.createBeep(800, 0.1, 'square');
      },
      
      playPlace() {
        this.createBeep(600, 0.15, 'sine');
      },
      
      playDelivery() {
        this.createBeep(1000, 0.3, 'sine');
      },
      
      playSuccess() {
        // Success chord
        setTimeout(() => this.createBeep(523, 0.2), 0);   // C
        setTimeout(() => this.createBeep(659, 0.2), 100); // E
        setTimeout(() => this.createBeep(784, 0.3), 200); // G
      },
      
      playFailure() {
        this.createBeep(200, 0.5, 'sawtooth');
      },
      
      playTimeout() {
        // Timeout warning
        this.createBeep(400, 0.3, 'triangle');
        setTimeout(() => this.createBeep(300, 0.3), 150);
      },
      
      playLevelUp() {
        // Level up fanfare
        const notes = [523, 659, 784, 1047]; // C, E, G, C octave
        notes.forEach((freq, i) => {
          setTimeout(() => this.createBeep(freq, 0.2), i * 100);
        });
      },
      
      playTrash() {
        this.createBeep(300, 0.2, 'sawtooth');
      }
    };
    
    console.log("‚úÖ Audio system configured");
    
    // =============================================================================
    // RIDDLE & CUSTOMER DATABASE (PHASE 2)
    // =============================================================================
    
    // All riddles for the game
    const RIDDLES = [
      // LEVEL 1 - Simple COUNT riddles (22 seconds)
      { id: "l1_1", text: "Golden grain blessed by Demeter with vine's crimson blood", type: "COUNT", level: 1, 
        counts: { bread: 1, tomato: 1 }},
      { id: "l1_2", text: "Hunter's prize paired with the cow's sacred gift", type: "COUNT", level: 1,
        counts: { meat: 1, cheese: 1 }},
      { id: "l1_3", text: "Zeus's forbidden treasure touched by flame's essence", type: "COUNT", level: 1,
        counts: { egg: 1, pepper: 1 }},
      { id: "l1_4", text: "Twin grains with single crimson orb", type: "COUNT", level: 1,
        counts: { bread: 2, tomato: 1 }},
      { id: "l1_5", text: "Double moon's gift crowning the beast", type: "COUNT", level: 1,
        counts: { cheese: 2, meat: 1 }},
      { id: "l1_6", text: "Sacred envelope: grain embraces cow's craft", type: "SANDWICH", level: 1,
        sandwich: ["bread", "cheese", "bread"]},
      { id: "l1_7", text: "Divine cradle: bread shelters vine's blood", type: "SANDWICH", level: 1,
        sandwich: ["bread", "tomato", "bread"]},
      { id: "l1_8", text: "Trinity of lunar discs", type: "COUNT", level: 1,
        counts: { cheese: 3 }},
      
      // LEVEL 2 - Divine EXCLUDE riddles (18 seconds)
      { id: "l2_1", text: "Blood and beast unite, but Zeus's egg brings doom", type: "EXCLUDE", level: 2,
        counts: { tomato: 1, meat: 1 }, exclude: ["egg"]},
      { id: "l2_2", text: "Double hunter's bounty, but moon's gift is forbidden", type: "EXCLUDE", level: 2,
        counts: { meat: 2 }, exclude: ["cheese"]},
      { id: "l2_3", text: "Fire and moon collide, but crimson blood is cursed", type: "EXCLUDE", level: 2,
        counts: { cheese: 1, pepper: 1 }, exclude: ["tomato"]},
      { id: "l2_4", text: "Twin lunar gifts blessing single crimson orb", type: "COUNT", level: 2,
        counts: { cheese: 2, tomato: 1 }},
      { id: "l2_5", text: "Warrior's meal: grain shields the hunter's prize", type: "SANDWICH", level: 2,
        sandwich: ["bread", "meat", "bread"]},
      { id: "l2_6", text: "Trio of vine's sacred blood", type: "COUNT", level: 2,
        counts: { tomato: 3 }},
      
      // LEVEL 3 - Legendary challenges (15 seconds)
      { id: "l3_1", text: "Trinity of power: grain, beast, crimson blood", type: "COUNT", level: 3,
        counts: { bread: 1, meat: 1, tomato: 1 }},
      { id: "l3_2", text: "Sacred triad: hunter's prize, moon's gift, flame's kiss", type: "COUNT", level: 3,
        counts: { meat: 1, cheese: 1, pepper: 1 }},
      { id: "l3_3", text: "Twin moons reign supreme, but fire is banished", type: "EXCLUDE", level: 3,
        counts: { cheese: 2 }, exclude: ["pepper"]},
      { id: "l3_4", text: "Inferno trapped in golden walls", type: "SANDWICH", level: 3,
        sandwich: ["bread", "pepper", "bread"]},
      { id: "l3_5", text: "Double beast blessing single flame", type: "COUNT", level: 3,
        counts: { meat: 2, pepper: 1 }},
      { id: "l3_6", text: "Hermes' perfect harmony: grain, blood, moon, beast", type: "COUNT", level: 3,
        counts: { bread: 1, tomato: 1, cheese: 1, meat: 1 }},
      { id: "l3_7", text: "Fill the divine plate completely with five sacred offerings", type: "TOTALCOUNT", level: 3,
        totalCount: 5},
      { id: "l3_8", text: "Medusa's challenge: All different, nothing repeated", type: "UNIQUE", level: 3,
        totalCount: 4, uniqueOnly: true},
      
      // ADDITIONAL LEVEL 1 RIDDLES - More variety for beginners
      { id: "l1_9", text: "The baker's foundation and Zeus's sacred creation", type: "COUNT", level: 1,
        counts: { bread: 1, egg: 1 }},
      { id: "l1_10", text: "Fire's kiss meets the earth's spice", type: "COUNT", level: 1,
        counts: { pepper: 2 }},
      { id: "l1_11", text: "Three gifts from Demeter's golden fields", type: "COUNT", level: 1,
        counts: { bread: 3 }},
      { id: "l1_12", text: "The vine's blood with fire's burn", type: "COUNT", level: 1,
        counts: { tomato: 1, pepper: 1 }},
      
      // ADDITIONAL LEVEL 2 RIDDLES - More complex combinations
      { id: "l2_9", text: "The feast of plenty, but no hunter's prize shall touch", type: "EXCLUDE", level: 2,
        totalCount: 4, excludes: ["meat"]},
      { id: "l2_10", text: "Sacred offerings abound, yet avoid Zeus's creation", type: "EXCLUDE", level: 2,
        totalCount: 3, excludes: ["egg"]},
      { id: "l2_11", text: "The forest's bread wrapped around earth's fire", type: "SANDWICH", level: 2,
        bread: true, filling: ["pepper"]},
      { id: "l2_12", text: "Golden grain embraces the hunter's prize with sacred gift", type: "SANDWICH", level: 2,
        bread: true, filling: ["meat", "cheese"]},
      { id: "l2_13", text: "Fill the sacred vessel, but let no vine's blood flow", type: "EXCLUDE", level: 2,
        totalCount: 5, excludes: ["tomato"]},
      
      // ADDITIONAL LEVEL 3 RIDDLES - Ultimate challenges
      { id: "l3_9", text: "The trinity of the earth: bread, meat, and sacred gift only", type: "COUNT", level: 3,
        counts: { bread: 1, meat: 1, cheese: 1 }},
      { id: "l3_10", text: "Five different souls, each unique in the divine vessel", type: "UNIQUE", level: 3,
        totalCount: 5, uniqueOnly: true},
      { id: "l3_11", text: "Hermes' perfect symmetry: two of grain, two of earth's fire", type: "COUNT", level: 3,
        counts: { bread: 2, pepper: 2 }},
      { id: "l3_12", text: "The feast of four, with no repeating souls", type: "UNIQUE", level: 3,
        totalCount: 4, uniqueOnly: true},
      { id: "l3_13", text: "Exactly five offerings, but the hunter brings nothing", type: "EXCLUDE", level: 3,
        totalCount: 5, excludes: ["meat"]},
      { id: "l3_14", text: "The divine sandwich of Zeus: his creation wrapped in gold", type: "SANDWICH", level: 3,
        bread: true, filling: ["egg"]},
      { id: "l3_15", text: "Three unique souls only, each different from the others", type: "UNIQUE", level: 3,
        totalCount: 3, uniqueOnly: true}
    ];
    
    // Customer database
    const CUSTOMERS = [
      { id: "minotaur", name: "Minotaur", 
        success: ["The labyrinth rests.", "Straight through.", "Your path is clear."],
        failure: ["Lost already?", "Wrong turn taken.", "The maze claims you."], 
        timeout: ["The maze does not wait.", "Time traps the lost.", "Choose swiftly."]},
      { id: "medusa", name: "Medusa",
        success: ["Stone-cold perfect.", "Acceptable gaze.", "Your eyes see truth."],
        failure: ["You froze.", "Turned to failure.", "Gaze upon your mistake."],
        timeout: ["Petrified by seconds?", "Time turns you to stone.", "Hesitation kills."]},
      { id: "hermes", name: "Hermes",
        success: ["Swift and sure.", "Wings approved.", "Speed and precision unite."],
        failure: ["Outpaced again.", "Too slow, mortal.", "Haste without thought."],
        timeout: ["Wings beat you.", "Swift time escapes.", "The messenger departs."]},
      { id: "sphinx", name: "Sphinx",
        success: ["Your mind is awake.", "The riddle yields.", "Wisdom is shown."],
        failure: ["Answer me properly.", "Your mind falters.", "Think harder, mortal."],
        timeout: ["Silence is not an answer.", "Time riddles all.", "The sphinx waits not."]},
      { id: "pegasus", name: "Pegasus",
        success: ["Wings of satisfaction.", "Sky-high approval.", "Divine flight achieved."],
        failure: ["Grounded by error.", "Wings clipped.", "Fall from grace."],
        timeout: ["Time flies away.", "Swift as wind departs.", "The sky cannot wait."]},
      { id: "poseidon", name: "Poseidon",
        success: ["The seas are pleased.", "Tidal perfection.", "Oceanic approval flows."],
        failure: ["The depths are angry.", "Storms brew from failure.", "Poseidon's wrath rises."],
        timeout: ["The tide waits not.", "Waves of time crash over.", "The ocean reclaims all."]},
      { id: "ghost", name: "Restless Spirit",
        success: ["The veil shivers.", "Peace flows.", "Rest is granted."],
        failure: ["Whispers say no.", "Unrest grows.", "The dead are displeased."],
        timeout: ["Time slipped through you.", "Eternity waits not.", "The spirit fades."]},
      { id: "chimera", name: "Chimera",
        success: ["All three heads agree!", "Lion purrs, goat bleats, serpent hisses approval.", "Unified in satisfaction."],
        failure: ["The lion roars, goat screams, serpent spits!", "Three minds in chaos.", "Disagreement breeds fury."],
        timeout: ["Three heads, three opinions, three times the impatience.", "Chimera cannot wait.", "Beast's patience expires."]}
    ];
    
    // Randomize customer order for each game
    function shuffleCustomers() {
      const shuffled = [...CUSTOMERS];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }
    
    console.log(`‚úÖ Loaded ${RIDDLES.length} riddles and ${CUSTOMERS.length} customers`);
    
    // =============================================================================
    // GAME STATE
    // =============================================================================
    
    // Main game state object
    const game = {
      // Game flow
      state: 'menu',              // 'menu', 'playing', 'paused', 'won'
      score: 0,
      level: 1,
      
      // Player
      player: {
        x: 640,                   // Start at table center
        y: 360,
        carrying: null,           // null or ingredient name string
        currentZone: null,        // Which interaction zone player is in
        speed: CONFIG.PLAYER_SPEED
      },
      
      // Plate & ingredients
      plate: [],                  // Array of ingredient strings, max 5
      
      // Riddle system
      currentRiddle: null,        // Current riddle object
      riddleIndex: 0,             // Track which riddle we're on
      usedRiddles: [],            // Track used riddles to avoid repeats
      
      // Customer system
      currentCustomer: null,      // Current customer object
      customerIndex: 0,           // Rotation index
      customerMessage: '',        // What customer is saying
      messageTimer: 0,            // How long to show message
      shuffledCustomers: [],      // Randomized customer order
      customerPosition: { x: 0, y: 0 }, // Current customer position
      customerState: 'walking_in',    // 'walking_in', 'waiting', 'walking_out'
      customerAnimation: 0,           // Animation frame counter
      
      // Timing
      timer: CONFIG.LEVEL_1_TIME, // Current timer
      timePerRiddle: CONFIG.LEVEL_1_TIME,
      lastTime: 0,                // For delta time
      deliveryDebounce: 0,        // Prevent double delivery
      
      // Feedback
      toastMessage: '',           // Current toast message
      toastTimer: 0,              // How long to show toast
      
      // Progressive Story System
      night: 1,                   // Current night of eternal servitude
      totalPoints: 0,             // Total points across all nights for story progression
      storyUnlocked: [],          // Array of unlocked story fragment IDs
      collarCracks: 0,            // Visual collar progression (0-5 cracks)
      showingStory: false,        // Whether story panel is currently displayed
      storyPanel: null,           // Current story panel content
      
      // God Relationship System - Character Arcs
      godRelationships: {
        medusa: { favor: 0, interactions: 0, arc: 'hostile' },     // Starts hostile, becomes protective
        minotaur: { favor: 0, interactions: 0, arc: 'neutral' },   // Respects skill, offers teaching  
        poseidon: { favor: 0, interactions: 0, arc: 'testing' },   // Tests worth with impossible orders
        hermes: { favor: 0, interactions: 0, arc: 'neutral' },     // Quick to judge, quick to forgive
        sphinx: { favor: 0, interactions: 0, arc: 'mysterious' },  // Riddles within riddles
        zeus: { favor: 0, interactions: 0, arc: 'demanding' },     // Expects perfection
        hera: { favor: 0, interactions: 0, arc: 'judgmental' },    // Watches for weakness
        hydra: { favor: 0, interactions: 0, arc: 'chaotic' },      // Unpredictable beast
        chimera: { favor: 0, interactions: 0, arc: 'volatile' },   // Three personalities in one
        ghost: { favor: 0, interactions: 0, arc: 'sorrowful' }     // Seeks understanding
      },
      
      // New Cooking Mechanics
      cookingItem: null,          // Item currently being cooked in oven
      cookingTimer: 0,            // Timer for cooking (3 seconds = 3000ms)
      cookingDuration: 3000,      // How long items take to cook
      
      // Debug
      debugMode: false,
      showHitboxes: false,
      frameCount: 0,
      lastFPSTime: 0,
      currentFPS: 60
    };
    
    console.log("‚úÖ Game state initialized:", game);
    
    // =============================================================================
    // INPUT SYSTEM (KEYBOARD ONLY)
    // =============================================================================
    
    const input = {
      keys: {},
      keyPressed: {}, // Track single presses to prevent repeats
      
      init() {
        // Keydown handler
        document.addEventListener('keydown', (e) => {
          const key = e.key.toLowerCase();
          this.keys[key] = true;
          
          // Prevent defaults for game keys
          if (['w','a','s','d','e','q','x','v','enter','escape'].includes(key)) {
            e.preventDefault();
          }
          
          // Special keys
          if (key === 'escape' && game.state === 'playing') {
            game.state = 'paused';
            console.log("Game paused");
          } else if (key === 'escape' && game.state === 'paused') {
            game.state = 'playing';
            console.log("Game resumed");
          }
          
          // Debug keys
          if (key === '`' || key === '~') {
            game.debugMode = !game.debugMode;
            console.log('Debug mode:', game.debugMode);
          }
          
          if (key === 'f1' && game.debugMode) {
            game.showHitboxes = !game.showHitboxes;
            console.log('Show hitboxes:', game.showHitboxes);
          }
        });
        
        // Keyup handler
        document.addEventListener('keyup', (e) => {
          const key = e.key.toLowerCase();
          this.keys[key] = false;
          this.keyPressed[key] = false;
        });
        
        // Window blur (auto-pause)
        window.addEventListener('blur', () => {
          this.keys = {}; // Clear all keys
          this.keyPressed = {};
          if (game.state === 'playing') {
            game.state = 'paused';
            console.log("Game auto-paused (window blur)");
          }
        });
        
        console.log('‚úÖ Input system initialized');
      },
      
      // Check if key is currently pressed
      isPressed(key) {
        return !!this.keys[key.toLowerCase()];
      },
      
      // Check if key was just pressed (single press)
      wasPressed(key) {
        const k = key.toLowerCase();
        if (this.keys[k] && !this.keyPressed[k]) {
          this.keyPressed[k] = true;
          return true;
        }
        return false;
      },
      
      // Get movement vector (normalized for diagonal)
      getMovementVector() {
        let x = 0, y = 0;
        
        if (this.isPressed('a')) x -= 1;
        if (this.isPressed('d')) x += 1;
        if (this.isPressed('w')) y -= 1;
        if (this.isPressed('s')) y += 1;
        
        // Normalize diagonal movement
        if (x !== 0 && y !== 0) {
          x *= 0.707; // 1/sqrt(2)
          y *= 0.707;
        }
        
        return { x, y };
      }
    };
    
    // =============================================================================
    // UTILITY FUNCTIONS
    // =============================================================================
    
    // Distance helper
    function distance(x1, y1, x2, y2) {
      return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    }
    
    // Random choice helper
    function randomChoice(array) {
      return array[Math.floor(Math.random() * array.length)];
    }
    
    // Toast message system
    function showToast(message) {
      game.toastMessage = message;
      game.toastTimer = 2000; // Show for 2 seconds
      console.log(`Toast: ${message}`);
    }
    
    // =============================================================================
    // RIDDLE VALIDATION SYSTEM (PHASE 2)
    // =============================================================================
    
    // Validate plate against riddle
    function validatePlate(plate, riddle) {
      if (!riddle) return { success: false, reason: "No active riddle" };
      
      // COUNT validation
      if (riddle.type === "COUNT") {
        const plateCounts = {};
        plate.forEach(item => {
          plateCounts[item] = (plateCounts[item] || 0) + 1;
        });
        
        // Check exact matches
        for (let ingredient in riddle.counts) {
          if (plateCounts[ingredient] !== riddle.counts[ingredient]) {
            return { success: false, reason: "Wrong ingredients" };
          }
        }
        
        // Check no extras
        for (let ingredient in plateCounts) {
          if (!riddle.counts[ingredient]) {
            return { success: false, reason: "Extra ingredients" };
          }
        }
        
        return { success: true };
      }
      
      // EXCLUDE validation
      if (riddle.type === "EXCLUDE") {
        const plateCounts = {};
        plate.forEach(item => {
          plateCounts[item] = (plateCounts[item] || 0) + 1;
        });
        
        // Check excluded items
        for (let excluded of riddle.exclude || []) {
          if (plateCounts[excluded] > 0) {
            return { success: false, reason: `Contains ${excluded}!` };
          }
        }
        
        // Check required items
        for (let ingredient in riddle.counts) {
          if (plateCounts[ingredient] !== riddle.counts[ingredient]) {
            return { success: false, reason: "Wrong ingredients" };
          }
        }
        
        return { success: true };
      }
      
      // SANDWICH validation
      if (riddle.type === "SANDWICH") {
        if (plate.length !== riddle.sandwich.length) {
          return { success: false, reason: `Need exactly ${riddle.sandwich.length} items` };
        }
        
        for (let i = 0; i < riddle.sandwich.length; i++) {
          if (plate[i] !== riddle.sandwich[i]) {
            return { success: false, reason: "Wrong sandwich order" };
          }
        }
        
        return { success: true };
      }
      
      // TOTALCOUNT validation (Phase 4 - New type)
      if (riddle.type === "TOTALCOUNT") {
        if (plate.length !== riddle.totalCount) {
          return { success: false, reason: `Need exactly ${riddle.totalCount} items` };
        }
        
        return { success: true };
      }
      
      // UNIQUE validation (Phase 4 - New type)
      if (riddle.type === "UNIQUE") {
        if (plate.length !== riddle.totalCount) {
          return { success: false, reason: `Need exactly ${riddle.totalCount} items` };
        }
        
        const uniqueItems = new Set(plate);
        if (uniqueItems.size !== plate.length) {
          return { success: false, reason: "All items must be different!" };
        }
        
        return { success: true };
      }
      
      // COOKING validation - requires specific cooked/cut preparations
      if (riddle.type === "COOKING") {
        if (plate.length !== riddle.required.length) {
          return { success: false, reason: `Need exactly ${riddle.required.length} items` };
        }
        
        for (let i = 0; i < riddle.required.length; i++) {
          if (plate[i] !== riddle.required[i]) {
            return { success: false, reason: `Wrong preparation: need ${riddle.required[i]}` };
          }
        }
        
        return { success: true };
      }
      
      return { success: false, reason: "Unknown riddle type" };
    }
    
    // Get next riddle
    function nextRiddle() {
      // Get riddles for current level
      const levelRiddles = RIDDLES.filter(r => r.level === game.level);
      
      // Avoid repeats
      const available = levelRiddles.filter(r => !game.usedRiddles.includes(r.id));
      
      if (available.length === 0) {
        // Reset if we've used all riddles
        game.usedRiddles = [];
        nextRiddle();
        return;
      }
      
      // Pick random riddle
      game.currentRiddle = randomChoice(available);
      game.usedRiddles.push(game.currentRiddle.id);
      
      // Reset timer with bonus time for cooking riddles
      game.timer = game.timePerRiddle;
      if (game.currentRiddle.timeBonus) {
        game.timer += game.currentRiddle.timeBonus;
        console.log(`‚è∞ Added ${game.currentRiddle.timeBonus}s bonus time for cooking/cutting riddle`);
      }
      
      // Get next customer from existing shuffled order (NO RE-SHUFFLING)
      game.customerIndex++;
      if (game.customerIndex >= game.shuffledCustomers.length) {
        game.customerIndex = 0; // Loop back to start of list
      }
      game.currentCustomer = game.shuffledCustomers[game.customerIndex];
      game.customerMessage = '';
      game.messageTimer = 0;
      
      // Reset customer animation
      game.customerState = 'walking_in';
      game.customerPosition.x = KITCHEN.CUSTOMER_AREA.LEFT;
      game.customerPosition.y = KITCHEN.CUSTOMER_AREA.ENTRANCE_Y;
      game.customerAnimation = 0;
      
      // Clear plate
      game.plate = [];
      
      console.log(`New riddle: ${game.currentRiddle.text} (${game.currentRiddle.type}) - ${game.timer}s`);
    }
    
    // Update level based on score
    function updateLevel() {
      const prevLevel = game.level;
      
      if (game.score >= CONFIG.LEVEL_3_SCORE) {
        game.level = 3;
        game.timePerRiddle = CONFIG.LEVEL_3_TIME;
      } else if (game.score >= CONFIG.LEVEL_2_SCORE) {
        game.level = 2;
        game.timePerRiddle = CONFIG.LEVEL_2_TIME;
      }
      
      if (game.level > prevLevel) {
        showToast(`SPEED UP! Level ${game.level}`);
        console.log(`Level up to ${game.level}! Time per riddle: ${game.timePerRiddle}s`);
        AUDIO.playLevelUp(); // Phase 3 - Audio feedback
      }
    }
    
    // =============================================================================
    // COLLISION & ZONE DETECTION
    // =============================================================================
    
    // Check what zone the player is in
    function updatePlayerZone() {
      const player = game.player;
      const prevZone = player.currentZone;
      player.currentZone = null;
      
      // Check table zone (circular)
      const tableDist = distance(player.x, player.y, 
                                KITCHEN.POSITIONS.TABLE.x, 
                                KITCHEN.POSITIONS.TABLE.y);
      if (tableDist < KITCHEN.ZONES.TABLE_RADIUS) {
        player.currentZone = 'table';
        return;
      }
      
      // Check counter/delivery zone (rectangular)
      const counter = KITCHEN.POSITIONS.COUNTER;
      if (Math.abs(player.x - counter.x) < KITCHEN.ZONES.COUNTER_WIDTH/2 &&
          Math.abs(player.y - counter.y) < KITCHEN.ZONES.COUNTER_HEIGHT/2 + 30) {
        player.currentZone = 'counter';
        return;
      }
      
      // Check trash zone (circular)
      const trashDist = distance(player.x, player.y, 
                                KITCHEN.POSITIONS.TRASH.x, 
                                KITCHEN.POSITIONS.TRASH.y);
      if (trashDist < KITCHEN.ZONES.TRASH_RADIUS) {
        player.currentZone = 'trash';
        return;
      }
      
      // Check oven zone (circular)
      const ovenDist = distance(player.x, player.y, 
                               KITCHEN.POSITIONS.OVEN.x, 
                               KITCHEN.POSITIONS.OVEN.y);
      if (ovenDist < KITCHEN.ZONES.OVEN_RADIUS) {
        player.currentZone = 'oven';
        return;
      }
      
      // Check cutting board zone (circular)
      const cuttingDist = distance(player.x, player.y, 
                                  KITCHEN.POSITIONS.CUTTING_BOARD.x, 
                                  KITCHEN.POSITIONS.CUTTING_BOARD.y);
      if (cuttingDist < KITCHEN.ZONES.CUTTING_RADIUS) {
        player.currentZone = 'cutting_board';
        return;
      }
      
      // Check ingredient bins (circular)
      for (let [ingredient, pos] of Object.entries(KITCHEN.POSITIONS.BINS)) {
        const dist = distance(player.x, player.y, pos.x, pos.y);
        if (dist < KITCHEN.ZONES.BIN_RADIUS) {
          player.currentZone = `bin_${ingredient.toLowerCase()}`;
          return;
        }
      }
      
      // Log zone changes for debugging
      if (prevZone !== player.currentZone && game.debugMode) {
        console.log(`Zone change: ${prevZone} ‚Üí ${player.currentZone}`);
      }
    }
    
    // =============================================================================
    // CUSTOMER ANIMATION SYSTEM (PHASE 5)
    // =============================================================================
    
    // Update customer walking animation
    function updateCustomerAnimation(deltaTime) {
      if (!game.currentCustomer) return;
      
      const animSpeed = 2; // pixels per frame
      game.customerAnimation += deltaTime;
      
      if (game.customerState === 'walking_in') {
        // Walk from entrance to queue position
        game.customerPosition.x += animSpeed;
        if (game.customerPosition.x >= KITCHEN.CUSTOMER_AREA.QUEUE_X) {
          game.customerPosition.x = KITCHEN.CUSTOMER_AREA.QUEUE_X;
          game.customerState = 'waiting';
        }
      } else if (game.customerState === 'walking_out') {
        // Walk from queue to exit
        game.customerPosition.y += animSpeed;
        if (game.customerPosition.y >= KITCHEN.CUSTOMER_AREA.EXIT_Y) {
          game.customerPosition.y = KITCHEN.CUSTOMER_AREA.EXIT_Y;
          game.customerState = 'gone';
        }
      }
    }
    
    // =============================================================================
    // PLAYER MECHANICS
    // =============================================================================
    
    // Player movement update
    function updatePlayer(deltaTime) {
      if (game.state !== 'playing') return;
      
      const movement = input.getMovementVector();
      const player = game.player;
      
      // Calculate new position
      const newX = player.x + (movement.x * player.speed);
      const newY = player.y + (movement.y * player.speed);
      
      // Apply boundaries
      const halfSize = CONFIG.PLAYER_SIZE / 2;
      player.x = Math.max(KITCHEN.BOUNDS.LEFT + halfSize,
                         Math.min(KITCHEN.BOUNDS.RIGHT - halfSize, newX));
      player.y = Math.max(KITCHEN.BOUNDS.TOP + halfSize,
                         Math.min(KITCHEN.BOUNDS.BOTTOM - halfSize, newY));
      
      // Update current zone
      updatePlayerZone();
    }
    
    // Pickup/place mechanics
    function handleInteraction() {
      const player = game.player;
      const zone = player.currentZone;
      
      if (!zone) {
        showToast("Nothing here to interact with");
        return;
      }
      
      // At ingredient bin
      if (zone.startsWith('bin_')) {
        const ingredient = zone.replace('bin_', '');
        
        if (player.carrying) {
          showToast("Hands full!");
        } else {
          player.carrying = ingredient;
          showToast(`Picked up ${ingredient}`);
          console.log(`Picked up: ${ingredient}`);
          AUDIO.playPickup(); // Phase 3 - Audio feedback
        }
      }
      
      // At table
      else if (zone === 'table') {
        if (player.carrying) {
          if (game.plate.length >= CONFIG.MAX_PLATE_SIZE) {
            showToast("Plate is full!");
          } else {
            game.plate.push(player.carrying);
            showToast(`Placed ${player.carrying}`);
            console.log(`Plate now: ${game.plate.join(', ')}`);
            player.carrying = null;
            AUDIO.playPlace(); // Phase 3 - Audio feedback
          }
        } else {
          showToast("Pick up an ingredient first");
        }
      }
      
      // At cutting board
      else if (zone === 'cutting_board') {
        if (player.carrying) {
          // Cut the item directly at the cutting board - only certain items can be cut
          const ingredient = player.carrying;
          const cuttableItems = ['tomato', 'cheese', 'meat', 'avocado', 'pepper'];
          
          if (cuttableItems.includes(ingredient)) {
            player.carrying = `cut_${ingredient}`;
            showToast(`Sliced ${ingredient} on ancient cutting board!`);
            console.log(`Cut ${ingredient} into cut_${ingredient}`);
            AUDIO.playPlace(); // Cutting sound
          } else {
            showToast(`${ingredient} cannot be cut! (Only: tomato, cheese, meat, avocado, pepper)`);
          }
        } else {
          showToast("Bring ingredient to cutting board to slice");
        }
      }
      
      // At oven
      else if (zone === 'oven') {
        if (player.carrying) {
          const ingredient = player.carrying;
          const cookableItems = ['meat', 'egg', 'bacon'];
          
          if (cookableItems.includes(ingredient)) {
            game.cookingItem = ingredient;
            game.cookingTimer = game.cookingDuration; // Start 3-second cooking timer
            player.carrying = null;
            showToast(`${game.cookingItem} cooking... 3 seconds (V to retrieve)`);
            console.log(`Started cooking: ${game.cookingItem} for ${game.cookingDuration}ms`);
            AUDIO.playPlace();
          } else {
            showToast(`${ingredient} cannot be cooked! (Only: meat, egg, bacon)`);
          }
        } else if (game.cookingItem) {
          const timeLeft = Math.ceil(game.cookingTimer / 1000);
          if (timeLeft > 0) {
            showToast(`Still cooking... ${timeLeft}s remaining`);
          } else {
            showToast("Cooked! Press V to retrieve");
          }
        } else {
          showToast("Place ingredient to cook");
        }
      }
    }
    
    // Undo function (Q key at table)
    function handleUndo() {
      if (game.player.currentZone !== 'table') {
        showToast("Go to table to undo");
        return;
      }
      
      if (game.plate.length === 0) {
        showToast("Nothing to undo");
        return;
      }
      
      const removed = game.plate.pop();
      showToast(`Removed ${removed}`);
      console.log(`Undid ${removed}, plate now: ${game.plate.join(', ')}`);
      AUDIO.playPlace(); // Phase 3 - Audio feedback (same as place, but reversed)
    }
    
    // Trash function (X key at trash)
    function handleTrash() {
      if (game.player.currentZone !== 'trash') {
        showToast("Go to trash bin to discard");
        return;
      }
      
      if (!game.player.carrying) {
        showToast("Nothing to trash");
        return;
      }
      
      const trashed = game.player.carrying;
      game.player.carrying = null;
      showToast(`Trashed ${trashed}`);
      console.log(`Trashed: ${trashed}`);
      AUDIO.playTrash(); // Phase 3 - Audio feedback
    }
    
    // Cutting now handled directly at cutting board via handleInteraction()
    // No separate cutting function needed
    
    // Oven retrieval function (V key at oven)
    function handleOvenRetrieve() {
      if (game.player.currentZone !== 'oven') {
        showToast("Go to oven to retrieve cooked items");
        return;
      }
      
      if (!game.cookingItem) {
        showToast("Nothing cooking in oven");
        return;
      }
      
      if (game.cookingTimer > 0) {
        const timeLeft = Math.ceil(game.cookingTimer / 1000);
        showToast(`Still cooking! Wait ${timeLeft} more seconds`);
        return;
      }
      
      if (game.player.carrying) {
        showToast("Hands full! Can't retrieve from oven");
        return;
      }
      
      const cookedItem = `cooked_${game.cookingItem}`;
      game.player.carrying = cookedItem;
      showToast(`Retrieved ${cookedItem} from divine flames!`);
      console.log(`Retrieved: ${cookedItem}`);
      game.cookingItem = null;
      game.cookingTimer = 0;
      AUDIO.playPickup();
    }
    
    // Delivery function (Phase 2 - Real validation)
    function handleDelivery() {
      if (game.player.currentZone !== 'counter') {
        showToast("Go to counter to deliver");
        return;
      }
      
      if (game.deliveryDebounce > 0) return; // Prevent double delivery
      
      if (game.plate.length === 0) {
        showToast("Nothing to serve");
        return;
      }
      
      // Validate the plate
      const result = validatePlate(game.plate, game.currentRiddle);
      
      if (result.success) {
        // Success!
        game.score++;
        game.totalPoints++; // Track total points for story progression
        game.customerMessage = randomChoice(game.currentCustomer.success);
        game.messageTimer = 2000;
        showToast("Correct! +1 point");
        console.log(`SUCCESS! Score: ${game.score}`);
        AUDIO.playSuccess(); // Phase 3 - Audio feedback
        
        // Update god relationship (positive)
        updateGodRelationship(game.currentCustomer.id, true);
        
        // Check for story progression
        checkStoryProgression();
        
        // Check for level up
        updateLevel();
        
        // Check for win
        if (game.score >= CONFIG.WIN_SCORE) {
          game.state = 'won';
          console.log("GAME WON!");
          return;
        }
        
        // Customer walks out, then next riddle
        game.customerState = 'walking_out';
        setTimeout(() => nextRiddle(), 2500); // Give time for walking animation
      } else {
        // Failure
        game.customerMessage = randomChoice(game.currentCustomer.failure);
        game.messageTimer = 2000;
        showToast(`Wrong! ${result.reason}`);
        console.log(`FAILED: ${result.reason}`);
        AUDIO.playFailure(); // Phase 3 - Audio feedback
        
        // Update god relationship (negative)
        updateGodRelationship(game.currentCustomer.id, false);
        
        // Customer walks out after feedback, then next riddle
        game.customerState = 'walking_out';
        setTimeout(() => nextRiddle(), 2500); // Give time for walking animation
      }
      
      // Clear plate and set debounce
      game.plate = [];
      game.deliveryDebounce = 300;
    }
    
    // =============================================================================
    // ADVANCED COOKING RIDDLES (WITH CUTTING & COOKING)
    // =============================================================================
    
    // Add simple and clear cooking riddles
    const ADVANCED_RIDDLES = [
      // Level 2 - Simple cutting challenges
      {
        id: 'cut_tomato_basic',
        text: "SLICE: 1 tomato (use cutting board)",
        level: 2,
        type: "COOKING",
        required: ["cut_tomato"],
        timeBonus: 10 // Extra time for preparation
      },
      {
        id: 'cut_cheese_simple',
        text: "SLICE: 1 cheese (use cutting board)",
        level: 2,
        type: "COOKING", 
        required: ["cut_cheese"],
        timeBonus: 10
      },
      
      // Level 2 - Simple cooking challenges
      {
        id: 'cooked_meat_basic',
        text: "COOK: 1 meat (use oven, wait 3 seconds)",
        level: 2,
        type: "COOKING",
        required: ["cooked_meat"],
        timeBonus: 15 // More time for cooking
      },
      {
        id: 'cooked_egg_basic',
        text: "COOK: 1 egg (use oven, wait 3 seconds)",
        level: 2,
        type: "COOKING",
        required: ["cooked_egg"],
        timeBonus: 15
      },
      
      // Level 3 - Mixed preparation (simple combinations)
      {
        id: 'meat_bread_combo',
        text: "COOK meat + raw bread (cook the meat, bread stays raw)",
        level: 3,
        type: "COOKING",
        required: ["cooked_meat", "bread"],
        timeBonus: 20
      },
      {
        id: 'tomato_cheese_combo',
        text: "SLICE tomato + SLICE cheese (both need cutting board)",
        level: 3,
        type: "COOKING",
        required: ["cut_tomato", "cut_cheese"],
        timeBonus: 15
      },
      {
        id: 'pepper_slice_basic',
        text: "SLICE: 1 pepper (use cutting board)",
        level: 2,
        type: "COOKING",
        required: ["cut_pepper"],
        timeBonus: 10
      },
      {
        id: 'cooked_bacon_basic',
        text: "COOK: 1 bacon (use oven, wait 3 seconds)",
        level: 2,
        type: "COOKING",
        required: ["cooked_bacon"],
        timeBonus: 15
      }
    ];
    
    // Merge advanced riddles with existing ones
    RIDDLES.push(...ADVANCED_RIDDLES);
    console.log(`‚úÖ ${ADVANCED_RIDDLES.length} advanced cooking riddles added!`);
    
    // =============================================================================
    // PROGRESSIVE STORY & GOD RELATIONSHIP SYSTEM
    // =============================================================================
    
    // Update god relationships based on interaction outcome
    function updateGodRelationship(godId, success) {
      if (!game.godRelationships[godId]) return;
      
      const god = game.godRelationships[godId];
      god.interactions++;
      
      if (success) {
        god.favor += 1;
        console.log(`üü¢ ${godId} favor increased: ${god.favor}`);
      } else {
        god.favor -= 1;
        console.log(`üî¥ ${godId} favor decreased: ${god.favor}`);
      }
      
      // Update character arc based on favor and interactions
      updateCharacterArc(godId, god);
    }
    
    // Update character arcs based on relationship progression
    function updateCharacterArc(godId, god) {
      const { favor, interactions, arc } = god;
      
      switch (godId) {
        case 'medusa':
          if (favor >= 3 && arc === 'hostile') {
            god.arc = 'protective';
            showToast("Medusa's eyes soften... she grows protective");
          }
          break;
          
        case 'minotaur':
          if (favor >= 2 && interactions >= 3 && arc === 'neutral') {
            god.arc = 'teaching';
            showToast("The Minotaur nods with respect - a teacher emerges");
          }
          break;
          
        case 'poseidon':
          if (favor <= -2 && arc === 'testing') {
            god.arc = 'challenging';
            showToast("Poseidon's tests grow impossible... beware his wrath");
          } else if (favor >= 4 && arc === 'testing') {
            god.arc = 'approving';
            showToast("The Sea Lord approves of your resilience");
          }
          break;
          
        case 'zeus':
          if (favor >= 5 && interactions >= 5) {
            god.arc = 'impressed';
            showToast("Zeus himself takes notice... is freedom near?");
          } else if (favor <= -3) {
            god.arc = 'wrathful';
            showToast("Thunder rumbles... Zeus grows impatient");
          }
          break;
      }
    }
    
    // Check for story progression milestones
    function checkStoryProgression() {
      const points = game.totalPoints;
      
      // Every 10 points, unlock story fragments
      if (points % 10 === 0 && points > 0) {
        const fragmentId = `fragment_${points}`;
        if (!game.storyUnlocked.includes(fragmentId)) {
          game.storyUnlocked.push(fragmentId);
          showStoryFragment(points);
          
          // Collar progression
          if (points % 20 === 0) {
            game.collarCracks = Math.min(5, game.collarCracks + 1);
            showToast(`*CRACK* Your collar loosens... (${game.collarCracks}/5)`);
          }
        }
      }
      
      // Night progression
      if (points >= game.night * 30) {
        advanceNight();
      }
    }
    
    // Show story fragment based on progress
    function showStoryFragment(points) {
      const fragments = {
        10: {
          title: "Night 1 - First Crack",
          text: "The iron collar is cold against your neck, but something shifts. The first crack appears - hairline thin, but hope nonetheless."
        },
        20: {
          title: "Hermes' Notice",
          text: "The messenger god pauses mid-flight. 'Interesting,' he mutters, watching you work. 'Perhaps not all mortals are worthless.'"
        },
        30: {
          title: "Night 2 - Growing Whispers",
          text: "The gods murmur among themselves. Some speak of your skill with grudging respect. Others plot greater challenges."
        },
        40: {
          title: "Medusa's Protection",
          text: "A younger god moves to strike you for a minor mistake. Medusa's serpents hiss, and he backs away. 'This one is under my watch,' she declares."
        },
        50: {
          title: "Night 3 - The Minotaur's Teaching",
          text: "Between riddles, the Minotaur shows you ancient cooking techniques. 'Strength comes not just from muscle,' he rumbles, 'but from skill.'"
        }
      };
      
      const fragment = fragments[points];
      if (fragment) {
        game.storyPanel = fragment;
        game.showingStory = true;
        console.log(`üìú Story fragment unlocked: ${fragment.title}`);
      }
    }
    
    // Advance to next night
    function advanceNight() {
      game.night++;
      game.score = 0; // Reset score for new night
      showToast(`üåô Night ${game.night} of eternal servitude begins...`);
      
      // Show night transition story
      const nightStories = {
        2: "Dawn never came. The collar dragged you back to the kitchen as the gods demand more.",
        3: "Your skill grows, but so does their hunger. The trials intensify.",
        4: "Whispers speak of ancient laws... perhaps a way to earn freedom through excellence.",
        5: "The collar grows lighter with each crack. Freedom feels close, yet so distant."
      };
      
      if (nightStories[game.night]) {
        game.storyPanel = {
          title: `Night ${game.night}`,
          text: nightStories[game.night]
        };
        game.showingStory = true;
      }
    }
    
    // =============================================================================
    // RENDERING SYSTEM
    // =============================================================================
    
    // Render kitchen layout
    function renderKitchen() {
      // Background - try to use feast hall image first
      const feastHallImg = ASSETS.kitchen?.feastHall;
      
      if (feastHallImg && ASSETS.loaded) {
        // Draw feast hall background scaled to fit screen
        ctx.drawImage(feastHallImg, 0, 0, canvas.width, canvas.height);
        
        // Add overlay for kitchen area definition
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.fillRect(0, 0, canvas.width, KITCHEN.BOUNDS.TOP); // Top
        ctx.fillRect(0, KITCHEN.BOUNDS.BOTTOM, canvas.width, canvas.height); // Bottom
        ctx.fillRect(0, 0, KITCHEN.BOUNDS.LEFT, canvas.height); // Left
        ctx.fillRect(KITCHEN.BOUNDS.RIGHT, 0, canvas.width, canvas.height); // Right
      } else {
        // Fallback - enhanced dungeon floor and walls
        // Floor with stone pattern
        const floorGradient = ctx.createLinearGradient(0, KITCHEN.BOUNDS.TOP, 0, KITCHEN.BOUNDS.BOTTOM);
        floorGradient.addColorStop(0, '#8B7355'); // Dark tan
        floorGradient.addColorStop(0.5, '#A0522D'); // Sienna
        floorGradient.addColorStop(1, '#654321'); // Dark brown
        ctx.fillStyle = floorGradient;
        ctx.fillRect(KITCHEN.BOUNDS.LEFT, KITCHEN.BOUNDS.TOP,
                     KITCHEN.BOUNDS.RIGHT - KITCHEN.BOUNDS.LEFT,
                     KITCHEN.BOUNDS.BOTTOM - KITCHEN.BOUNDS.TOP);
        
        // Stone floor tiles
        ctx.strokeStyle = '#2F1B14';
        ctx.lineWidth = 1;
        for (let x = KITCHEN.BOUNDS.LEFT; x < KITCHEN.BOUNDS.RIGHT; x += 50) {
          for (let y = KITCHEN.BOUNDS.TOP; y < KITCHEN.BOUNDS.BOTTOM; y += 50) {
            ctx.strokeRect(x, y, 50, 50);
          }
        }
        
        // Walls with dungeon theme
        const wallGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
        wallGradient.addColorStop(0, '#2F4F4F'); // Dark slate gray
        wallGradient.addColorStop(0.5, '#1C1C1C'); // Very dark gray
        wallGradient.addColorStop(1, '#000000'); // Black
        ctx.fillStyle = wallGradient;
        ctx.fillRect(0, 0, canvas.width, KITCHEN.BOUNDS.TOP); // Top
        ctx.fillRect(0, KITCHEN.BOUNDS.BOTTOM, canvas.width, canvas.height); // Bottom
        ctx.fillRect(0, 0, KITCHEN.BOUNDS.LEFT, canvas.height); // Left
        ctx.fillRect(KITCHEN.BOUNDS.RIGHT, 0, canvas.width, canvas.height); // Right
      }
      
      // Ingredient crates (Mount Olympus dungeon style with crate.png)
      const crateSize = 80; // Good size for clear crates with fixed positioning
      for (let [ingredient, pos] of Object.entries(KITCHEN.POSITIONS.BINS)) {
        
        // Draw wooden crate background using crate.png
        const crateImg = ASSETS.ui.crate;
        if (crateImg && ASSETS.loaded) {
          // Draw the crate as background
          ctx.drawImage(
            crateImg,
            pos.x - crateSize/2,
            pos.y - crateSize/2,
            crateSize,
            crateSize
          );
        } else {
          // Fallback wooden crate appearance
          const crateGradient = ctx.createLinearGradient(pos.x - crateSize/2, pos.y - crateSize/2, 
                                                        pos.x + crateSize/2, pos.y + crateSize/2);
          crateGradient.addColorStop(0, '#D2691E'); // Chocolate
          crateGradient.addColorStop(0.5, '#A0522D'); // Sienna
          crateGradient.addColorStop(1, '#8B4513'); // Saddle brown
          ctx.fillStyle = crateGradient;
          ctx.fillRect(pos.x - crateSize/2, pos.y - crateSize/2, crateSize, crateSize);
          
          // Wood planks pattern
          ctx.strokeStyle = '#654321';
          ctx.lineWidth = 2;
          for (let i = 0; i < 3; i++) {
            const plankY = pos.y - crateSize/2 + (i * crateSize/3);
            ctx.beginPath();
            ctx.moveTo(pos.x - crateSize/2, plankY);
            ctx.lineTo(pos.x + crateSize/2, plankY);
            ctx.stroke();
          }
        }
        
        // Torchlight glow around crate
        const torchFlicker = Math.sin(Date.now() * 0.005 + pos.x * 0.01) * 0.1 + 0.9;
        ctx.shadowColor = `rgba(255, 140, 0, ${0.3 * torchFlicker})`;
        ctx.shadowBlur = 10;
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 3;
        ctx.strokeRect(pos.x - crateSize/2, pos.y - crateSize/2, crateSize, crateSize);
        ctx.shadowBlur = 0;
        
        // Just show empty crates - no ingredient images on top
        // Crates are labeled below, that's enough visual indication
        
        // Ancient-style label with parchment appearance
        const labelWidth = 85;
        const labelHeight = 24;
        const labelY = pos.y + 32;
        
        // Parchment background
        ctx.fillStyle = '#F5DEB3'; // Wheat/parchment
        ctx.fillRect(pos.x - labelWidth/2, labelY, labelWidth, labelHeight);
        
        // Parchment border and aging
        ctx.strokeStyle = '#D2691E';
        ctx.lineWidth = 2;
        ctx.strokeRect(pos.x - labelWidth/2, labelY, labelWidth, labelHeight);
        
        // Burn marks for aged effect
        ctx.fillStyle = 'rgba(139, 69, 19, 0.2)';
        ctx.fillRect(pos.x - labelWidth/2 + 2, labelY + 2, labelWidth - 4, labelHeight - 4);
        
        // Ancient Greek-style text
        ctx.fillStyle = '#8B4513';
        ctx.font = 'bold 12px Cinzel, serif';
        ctx.textAlign = 'center';
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 0.5;
        ctx.strokeText(ingredient.toUpperCase(), pos.x, labelY + 16);
        ctx.fillText(ingredient.toUpperCase(), pos.x, labelY + 16);
        
        // Golden interaction highlight with divine glow
        if (game.player.currentZone === `bin_${ingredient.toLowerCase()}`) {
          ctx.strokeStyle = '#FFD700';
          ctx.lineWidth = 4;
          ctx.setLineDash([5, 5]);
          ctx.shadowColor = '#FFD700';
          ctx.shadowBlur = 20;
          ctx.strokeRect(pos.x - crateSize/2 - 8, pos.y - crateSize/2 - 8, 
                        crateSize + 16, crateSize + 16);
          ctx.setLineDash([]);
          ctx.shadowBlur = 0;
          
          // Divine particles effect
          for (let i = 0; i < 5; i++) {
            const angle = (Date.now() * 0.01 + i) % (Math.PI * 2);
            const radius = 50 + Math.sin(Date.now() * 0.01 + i) * 10;
            const sparkleX = pos.x + Math.cos(angle) * radius;
            const sparkleY = pos.y + Math.sin(angle) * radius;
            
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(sparkleX - 1, sparkleY - 1, 2, 2);
          }
        }
      }
      
      // Ancient Work Table (simplified - no plate)
      const table = KITCHEN.POSITIONS.TABLE;
      
      // Table surface - simple rectangular stone table
      const tableGrad = ctx.createLinearGradient(table.x - 120, table.y - 80, table.x - 120, table.y + 80);
      tableGrad.addColorStop(0, '#A0522D'); // Sienna
      tableGrad.addColorStop(0.5, '#8B4513'); // Saddle brown
      tableGrad.addColorStop(1, '#654321'); // Dark brown
      ctx.fillStyle = tableGrad;
      ctx.fillRect(table.x - 120, table.y - 80, 240, 160);
      
      // Stone table border
      ctx.strokeStyle = '#654321';
      ctx.lineWidth = 4;
      ctx.strokeRect(table.x - 120, table.y - 80, 240, 160);
      
      // Inner carved border for stone effect
      ctx.strokeStyle = '#D2691E';
      ctx.lineWidth = 2;
      ctx.strokeRect(table.x - 116, table.y - 76, 232, 152);
      
      // Simple stone texture lines
      ctx.strokeStyle = '#965A32';
      ctx.lineWidth = 1;
      for (let i = 0; i < 3; i++) {
        const lineY = table.y - 40 + (i * 40);
        ctx.beginPath();
        ctx.moveTo(table.x - 100, lineY);
        ctx.lineTo(table.x + 100, lineY);
        ctx.stroke();
      }
      
      // Ingredient slots on plate (Phase 3 - Show PNG ingredients)
      for (let i = 0; i < 5; i++) {
        const angle = (i * Math.PI * 2) / 5 - Math.PI/2; // Start at top, go clockwise
        const radius = 35; // Distance from center
        const slotX = table.x + Math.cos(angle) * radius;
        const slotY = table.y + Math.sin(angle) * radius;
        
        // Draw ingredient on plate if present
        if (game.plate[i]) {
          const ingredient = game.plate[i];
          let ingredientImg = null;
          
          // Check if it's a cut ingredient first
          if (ingredient.startsWith('cut_')) {
            ingredientImg = ASSETS.cutIngredients?.[ingredient];
          }
          
          // If not cut or cut asset not found, use regular ingredient
          if (!ingredientImg) {
            ingredientImg = ASSETS.ingredients[ingredient];
          }
          
          if (ingredientImg && ASSETS.loaded) {
            const imgSize = 48; // Good size for clear table display with fixed positioning
            
            ctx.drawImage(
              ingredientImg,
              slotX - imgSize/2,
              slotY - imgSize/2,
              imgSize,
              imgSize
            );
          } else {
            // Fallback to colored circle
            ctx.fillStyle = CONFIG.COLORS[ingredient.replace('cut_', '').replace('cooked_', '').toUpperCase()];
            ctx.beginPath();
            ctx.arc(slotX, slotY, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.stroke();
          }
        } else {
          // Empty slot indicator
          ctx.strokeStyle = '#CCC';
          ctx.lineWidth = 1;
          ctx.setLineDash([3, 3]);
          ctx.beginPath();
          ctx.arc(slotX, slotY, 12, 0, Math.PI * 2);
          ctx.stroke();
          ctx.setLineDash([]);
        }
      }
      
      // Highlight table if player is near
      if (game.player.currentZone === 'table') {
        ctx.strokeStyle = '#FFD700';
        ctx.lineWidth = 3;
        ctx.strokeRect(table.x - 105, table.y - 65, 210, 130);
      }
      
      // Ancient Delivery Altar (enhanced counter design)
      const counter = KITCHEN.POSITIONS.COUNTER;
      const altarWidth = 300;
      const altarHeight = 50;
      
      // Stone altar base with gradient
      const altarGrad = ctx.createLinearGradient(counter.x - altarWidth/2, counter.y - altarHeight/2,
                                                counter.x - altarWidth/2, counter.y + altarHeight/2);
      altarGrad.addColorStop(0, '#A0522D'); // Sienna
      altarGrad.addColorStop(0.5, '#8B4513'); // Saddle brown
      altarGrad.addColorStop(1, '#654321'); // Dark brown
      ctx.fillStyle = altarGrad;
      ctx.fillRect(counter.x - altarWidth/2, counter.y - altarHeight/2, altarWidth, altarHeight);
      
      // Ancient carved border
      ctx.strokeStyle = '#654321';
      ctx.lineWidth = 4;
      ctx.strokeRect(counter.x - altarWidth/2, counter.y - altarHeight/2, altarWidth, altarHeight);
      
      // Inner carved design
      ctx.strokeStyle = '#D2691E'; // Chocolate
      ctx.lineWidth = 2;
      ctx.strokeRect(counter.x - altarWidth/2 + 4, counter.y - altarHeight/2 + 4, 
                    altarWidth - 8, altarHeight - 8);
      
      // Ancient symbols/decorations on altar
      ctx.fillStyle = '#DAA520'; // Dark goldenrod
      ctx.font = 'bold 16px Cinzel, serif';
      ctx.textAlign = 'center';
      ctx.fillText('‚ö±', counter.x - 80, counter.y + 6);  // Left urn
      ctx.fillText('üèõ', counter.x, counter.y + 6);        // Center temple
      ctx.fillText('‚ö±', counter.x + 80, counter.y + 6);   // Right urn
      
      // Divine glow when player is near
      if (game.player.currentZone === 'counter') {
        // Golden divine aura
        ctx.shadowColor = '#FFD700';
        ctx.shadowBlur = 20;
        ctx.strokeStyle = '#FFD700';
        ctx.lineWidth = 4;
        ctx.setLineDash([8, 4]);
        ctx.strokeRect(counter.x - altarWidth/2 - 8, counter.y - altarHeight/2 - 8, 
                      altarWidth + 16, altarHeight + 16);
        ctx.setLineDash([]);
        ctx.shadowBlur = 0;
        
        // Divine particles around altar
        for (let i = 0; i < 6; i++) {
          const angle = (Date.now() * 0.003 + i) % (Math.PI * 2);
          const radius = 180 + Math.sin(Date.now() * 0.005 + i) * 15;
          const particleX = counter.x + Math.cos(angle) * radius;
          const particleY = counter.y + Math.sin(angle) * radius;
          
          ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
          ctx.beginPath();
          ctx.arc(particleX, particleY, 3, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Trash bin
      const trash = KITCHEN.POSITIONS.TRASH;
      const trashSize = 50;
      
      // Trash bin body (dark gray)
      ctx.fillStyle = '#404040';
      ctx.fillRect(trash.x - trashSize/2, trash.y - trashSize/2, trashSize, trashSize);
      
      // Trash bin lid (lighter gray)
      ctx.fillStyle = '#606060';
      ctx.fillRect(trash.x - trashSize/2 - 5, trash.y - trashSize/2 - 8, trashSize + 10, 15);
      
      // Trash bin border
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.strokeRect(trash.x - trashSize/2, trash.y - trashSize/2, trashSize, trashSize);
      ctx.strokeRect(trash.x - trashSize/2 - 5, trash.y - trashSize/2 - 8, trashSize + 10, 15);
      
      // Trash icon/lines
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(trash.x - 15, trash.y - 10);
      ctx.lineTo(trash.x - 15, trash.y + 15);
      ctx.moveTo(trash.x, trash.y - 10);
      ctx.lineTo(trash.x, trash.y + 15);
      ctx.moveTo(trash.x + 15, trash.y - 10);
      ctx.lineTo(trash.x + 15, trash.y + 15);
      ctx.stroke();
      
      // Highlight if player is near
      if (game.player.currentZone === 'trash') {
        ctx.strokeStyle = '#FFD700';
        ctx.lineWidth = 3;
        ctx.strokeRect(trash.x - trashSize/2 - 5, trash.y - trashSize/2 - 5, 
                      trashSize + 10, trashSize + 10);
      }
      
      // Divine Oven (cooking station)
      const oven = KITCHEN.POSITIONS.OVEN;
      const ovenImg = ASSETS.kitchen?.oven;
      const ovenSize = 80;
      
      if (ovenImg && ASSETS.loaded) {
        // Draw oven sprite
        ctx.drawImage(
          ovenImg,
          oven.x - ovenSize/2,
          oven.y - ovenSize/2,
          ovenSize,
          ovenSize
        );
      } else {
        // Fallback oven appearance - stone furnace
        const ovenGradient = ctx.createRadialGradient(oven.x, oven.y, 20, oven.x, oven.y, 40);
        ovenGradient.addColorStop(0, '#FF4500'); // Orange red (fire)
        ovenGradient.addColorStop(0.7, '#8B4513'); // Saddle brown (stone)
        ovenGradient.addColorStop(1, '#2F4F4F'); // Dark slate gray
        ctx.fillStyle = ovenGradient;
        ctx.fillRect(oven.x - ovenSize/2, oven.y - ovenSize/2, ovenSize, ovenSize);
        
        // Fire glow if something is cooking
        if (game.cookingItem) {
          ctx.fillStyle = 'rgba(255, 100, 0, 0.3)';
          ctx.beginPath();
          ctx.arc(oven.x, oven.y, ovenSize/2 + 10, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Ancient Cutting Board
      const cuttingBoard = KITCHEN.POSITIONS.CUTTING_BOARD;
      const boardImg = ASSETS.kitchen?.cuttingBoard;
      const boardSize = 80;
      
      if (boardImg && ASSETS.loaded) {
        // Draw cutting board sprite
        ctx.drawImage(
          boardImg,
          cuttingBoard.x - boardSize/2,
          cuttingBoard.y - boardSize/2,
          boardSize,
          boardSize
        );
      } else {
        // Fallback cutting board appearance - wooden surface
        const boardGradient = ctx.createLinearGradient(cuttingBoard.x - boardSize/2, cuttingBoard.y - boardSize/2, 
                                                      cuttingBoard.x + boardSize/2, cuttingBoard.y + boardSize/2);
        boardGradient.addColorStop(0, '#D2B48C'); // Tan (wood)
        boardGradient.addColorStop(0.5, '#CD853F'); // Peru
        boardGradient.addColorStop(1, '#8B4513'); // Saddle brown
        ctx.fillStyle = boardGradient;
        ctx.fillRect(cuttingBoard.x - boardSize/2, cuttingBoard.y - boardSize/2, boardSize, boardSize);
        
        // Draw cutting marks
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 1;
        for (let i = 0; i < 5; i++) {
          ctx.beginPath();
          ctx.moveTo(cuttingBoard.x - 20 + Math.random() * 40, cuttingBoard.y - 20);
          ctx.lineTo(cuttingBoard.x - 15 + Math.random() * 30, cuttingBoard.y + 20);
          ctx.stroke();
        }
      }
      
      // Interaction highlight
      if (game.player.currentZone === 'cutting_board') {
        ctx.strokeStyle = '#FFD700';
        ctx.lineWidth = 3;
        ctx.strokeRect(cuttingBoard.x - boardSize/2 - 5, cuttingBoard.y - boardSize/2 - 5, 
                      boardSize + 10, boardSize + 10);
      }
      
      // Labels
      ctx.fillStyle = '#FFF';
      ctx.font = 'bold 14px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('TABLE', table.x, table.y - 75);
      ctx.fillText('DIVINE ALTAR', counter.x, counter.y - 35);
      ctx.fillText('TRASH', trash.x, trash.y + 40);
      
      // Cooking station labels
      ctx.fillStyle = '#FFD700'; // Gold for divine stations
      ctx.font = 'bold 12px Cinzel, serif';
      ctx.fillText('DIVINE OVEN', oven.x, oven.y + 55);
      if (game.cookingItem) {
        if (game.cookingTimer > 0) {
          const timeLeft = Math.ceil(game.cookingTimer / 1000);
          ctx.fillStyle = '#FF6347'; // Tomato red for cooking status
          ctx.font = '10px Cinzel, serif';
          ctx.fillText(`Cooking ${game.cookingItem}... ${timeLeft}s`, oven.x, oven.y + 70);
          
          // Cooking progress bar
          const barWidth = 60;
          const barHeight = 6;
          const progress = 1 - (game.cookingTimer / game.cookingDuration);
          
          ctx.fillStyle = '#8B4513';
          ctx.fillRect(oven.x - barWidth/2, oven.y + 75, barWidth, barHeight);
          
          ctx.fillStyle = '#32CD32';
          ctx.fillRect(oven.x - barWidth/2, oven.y + 75, barWidth * progress, barHeight);
        } else {
          ctx.fillStyle = '#32CD32'; // Green when ready
          ctx.font = '10px Cinzel, serif';
          ctx.fillText(`${game.cookingItem} ready! Press V`, oven.x, oven.y + 70);
        }
      }
      
      ctx.fillStyle = '#FFD700'; // Gold for divine stations
      ctx.font = 'bold 12px Cinzel, serif';
      ctx.fillText('CUTTING BOARD', cuttingBoard.x, cuttingBoard.y + 55);
      if (game.player.currentZone === 'cutting_board' && game.player.carrying) {
        ctx.fillStyle = '#32CD32'; // Green when ready to cut
        ctx.font = '10px Cinzel, serif';
        ctx.fillText('Press E to slice', cuttingBoard.x, cuttingBoard.y + 70);
      }
    }
    
    // Render player (Enhanced with character sprite)
    function renderPlayer() {
      const player = game.player;
      
      // Character sprite usage with debug
      const characterImg = ASSETS.player?.character;
      // Only log debug info in debug mode to avoid console spam
      if (game.debugMode) {
        console.log('üé≠ Player sprite check:', characterImg ? 'LOADED' : 'MISSING', 'Assets loaded:', ASSETS.loaded);
      }
      
      if (characterImg && ASSETS.loaded) {
        const spriteSize = 80; // Good size for clear display with fixed positioning
        
        // Draw character sprite with perfect positioning
        ctx.drawImage(
          characterImg,
          player.x - spriteSize/2,
          player.y - spriteSize/2,
          spriteSize,
          spriteSize
        );
        
        // Add subtle glow around player for visibility
        ctx.shadowColor = 'rgba(255, 255, 255, 0.4)';
        ctx.shadowBlur = 10;
        ctx.drawImage(
          characterImg,
          player.x - spriteSize/2,
          player.y - spriteSize/2,
          spriteSize,
          spriteSize
        );
        ctx.shadowBlur = 0;
        
        // Debug indicator that sprite is working
        if (game.debugMode) {
          ctx.fillStyle = '#0F0';
          ctx.font = '12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('SPRITE', player.x, player.y - spriteSize/2 - 10);
        }
      } else {
        // FORCE debug message and fallback
        console.log('‚ùå Using fallback square - Character sprite not loaded!');
        ctx.fillStyle = CONFIG.COLORS.PLAYER;
        ctx.fillRect(player.x - CONFIG.PLAYER_SIZE/2,
                     player.y - CONFIG.PLAYER_SIZE/2,
                     CONFIG.PLAYER_SIZE, CONFIG.PLAYER_SIZE);
        
        // Player border
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.strokeRect(player.x - CONFIG.PLAYER_SIZE/2,
                       player.y - CONFIG.PLAYER_SIZE/2,
                       CONFIG.PLAYER_SIZE, CONFIG.PLAYER_SIZE);
        
        // Debug indicator that fallback is being used
        if (game.debugMode) {
          ctx.fillStyle = '#F00';
          ctx.font = '12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText('FALLBACK', player.x, player.y - CONFIG.PLAYER_SIZE/2 - 10);
        }
      }
      
      // Carried item (Enhanced with high quality rendering)
      if (player.carrying) {
        const carriedItem = player.carrying;
        let carriedImg = null;
        
        // Check if it's a cut ingredient first
        if (carriedItem.startsWith('cut_')) {
          carriedImg = ASSETS.cutIngredients?.[carriedItem];
        }
        
        // If not cut or cut asset not found, use regular ingredient
        if (!carriedImg) {
          carriedImg = ASSETS.ingredients[carriedItem];
        }
        
        if (carriedImg && ASSETS.loaded) {
          // Good size for clear display with fixed positioning
          const imgSize = 72; // Perfect size for clear visibility
          
          // Add background circle for contrast
          ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
          ctx.beginPath();
          ctx.arc(player.x, player.y - 50 - imgSize/2, imgSize/2 + 8, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#DAA520'; // Dark goldenrod
          ctx.lineWidth = 3;
          ctx.stroke();
          
          // Draw the ingredient image with perfect positioning
          ctx.drawImage(
            carriedImg,
            player.x - imgSize/2,
            player.y - 50 - imgSize,
            imgSize,
            imgSize
          );
          
          // Add enhanced golden glow effect
          ctx.shadowColor = '#FFD700';
          ctx.shadowBlur = 12;
          ctx.drawImage(
            carriedImg,
            player.x - imgSize/2,
            player.y - 50 - imgSize,
            imgSize,
            imgSize
          );
          ctx.shadowBlur = 0;
        } else {
          // Enhanced fallback display
          ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
          ctx.fillRect(player.x - 25, player.y - CONFIG.PLAYER_SIZE/2 - 30, 50, 24);
          ctx.strokeStyle = '#FFD700';
          ctx.lineWidth = 2;
          ctx.strokeRect(player.x - 25, player.y - CONFIG.PLAYER_SIZE/2 - 30, 50, 24);
          ctx.fillStyle = '#000';
          ctx.font = 'bold 12px Arial';
          ctx.textAlign = 'center';
          
          // Display proper name with cut/cooked indicators
          let displayName = carriedItem.toUpperCase();
          if (carriedItem.startsWith('cut_')) {
            displayName = 'CUT ' + carriedItem.replace('cut_', '').toUpperCase();
            ctx.fillStyle = '#FF6347'; // Red for cut items
          } else if (carriedItem.startsWith('cooked_')) {
            displayName = 'COOKED ' + carriedItem.replace('cooked_', '').toUpperCase();
            ctx.fillStyle = '#FF4500'; // Orange for cooked items
          }
          
          ctx.fillText(displayName, player.x, player.y - CONFIG.PLAYER_SIZE/2 - 12);
        }
      }
    }
    
    // Render customers (Phase 5 - Walking animation in customer area)
    function renderCustomers() {
      if (!game.currentCustomer || game.customerState === 'gone') return;
      
      // Render customer area background
      ctx.fillStyle = 'rgba(139, 69, 19, 0.3)'; // Brown customer area
      ctx.fillRect(KITCHEN.CUSTOMER_AREA.LEFT, KITCHEN.CUSTOMER_AREA.TOP, 
                   KITCHEN.CUSTOMER_AREA.RIGHT - KITCHEN.CUSTOMER_AREA.LEFT, 
                   KITCHEN.CUSTOMER_AREA.BOTTOM - KITCHEN.CUSTOMER_AREA.TOP);
      
      // Customer area border
      ctx.strokeStyle = '#8B4513';
      ctx.lineWidth = 2;
      ctx.strokeRect(KITCHEN.CUSTOMER_AREA.LEFT, KITCHEN.CUSTOMER_AREA.TOP, 
                     KITCHEN.CUSTOMER_AREA.RIGHT - KITCHEN.CUSTOMER_AREA.LEFT, 
                     KITCHEN.CUSTOMER_AREA.BOTTOM - KITCHEN.CUSTOMER_AREA.TOP);
      
      // Queue line indicator
      ctx.strokeStyle = '#654321';
      ctx.lineWidth = 3;
      ctx.setLineDash([10, 10]);
      ctx.beginPath();
      ctx.moveTo(KITCHEN.CUSTOMER_AREA.QUEUE_X, KITCHEN.CUSTOMER_AREA.TOP + 20);
      ctx.lineTo(KITCHEN.CUSTOMER_AREA.QUEUE_X, KITCHEN.CUSTOMER_AREA.BOTTOM - 20);
      ctx.stroke();
      ctx.setLineDash([]);
      
      const customerImg = ASSETS.customers[game.currentCustomer.id];
      const spriteWidth = 112;   // Good size for clear display with fixed positioning
      const spriteHeight = 144; // Good size for clear display with fixed positioning
      
      if (customerImg && ASSETS.loaded) {
        // Draw customer sprite at animated position with perfect clarity
        ctx.drawImage(
          customerImg,
          game.customerPosition.x - spriteWidth/2,
          game.customerPosition.y - spriteHeight/2,
          spriteWidth,
          spriteHeight
        );
        
        // Add divine glow effect if waiting
        if (game.customerState === 'waiting') {
          ctx.shadowColor = 'rgba(218, 165, 32, 0.7)'; // Dark goldenrod glow
          ctx.shadowBlur = 15;
          ctx.drawImage(
            customerImg,
            game.customerPosition.x - spriteWidth/2,
            game.customerPosition.y - spriteHeight/2,
            spriteWidth,
            spriteHeight
          );
          ctx.shadowBlur = 0;
          
          // Add mystical particles around waiting customer
          for (let i = 0; i < 3; i++) {
            const angle = (Date.now() * 0.005 + i * 2) % (Math.PI * 2);
            const radius = 60 + Math.sin(Date.now() * 0.01 + i) * 10;
            const particleX = game.customerPosition.x + Math.cos(angle) * radius;
            const particleY = game.customerPosition.y + Math.sin(angle) * radius;
            
            ctx.fillStyle = 'rgba(218, 165, 32, 0.8)';
            ctx.beginPath();
            ctx.arc(particleX, particleY, 2, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        // Ancient name plaque (only when waiting)
        if (game.customerState === 'waiting') {
          const plaqueWidth = 90;
          const plaqueHeight = 24;
          const plaqueY = game.customerPosition.y + 55;
          
          // Stone plaque background
          ctx.fillStyle = 'rgba(139, 69, 19, 0.9)'; // Dark brown stone
          ctx.fillRect(game.customerPosition.x - plaqueWidth/2, plaqueY, plaqueWidth, plaqueHeight);
          
          // Carved border effect
          ctx.strokeStyle = '#654321';
          ctx.lineWidth = 2;
          ctx.strokeRect(game.customerPosition.x - plaqueWidth/2, plaqueY, plaqueWidth, plaqueHeight);
          
          // Inner highlight
          ctx.strokeStyle = '#A0522D';
          ctx.lineWidth = 1;
          ctx.strokeRect(game.customerPosition.x - plaqueWidth/2 + 2, plaqueY + 2, 
                        plaqueWidth - 4, plaqueHeight - 4);
          
          // Engraved text effect
          ctx.fillStyle = '#DAA520'; // Dark goldenrod
          ctx.font = 'bold 12px Cinzel, serif';
          ctx.textAlign = 'center';
          ctx.strokeStyle = '#654321';
          ctx.lineWidth = 0.5;
          ctx.strokeText(game.currentCustomer.name, game.customerPosition.x, plaqueY + 16);
          ctx.fillText(game.currentCustomer.name, game.customerPosition.x, plaqueY + 16);
        }
        
        // Speech bubble (only when waiting and has message)
        if (game.customerState === 'waiting' && game.customerMessage && game.messageTimer > 0) {
          renderSpeechBubble(
            game.customerPosition.x,
            game.customerPosition.y - 60,
            game.customerMessage
          );
        }
      } else {
        // Fallback mythological figure (vertical oval)
        ctx.fillStyle = '#8A2BE2'; // Purple for mythical beings
        ctx.beginPath();
        ctx.ellipse(game.customerPosition.x, game.customerPosition.y, 30, 45, 0, 0, Math.PI * 2); // Vertical oval
        ctx.fill();
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Ancient crown or divine symbol
        ctx.fillStyle = '#DAA520';
        ctx.beginPath();
        ctx.ellipse(game.customerPosition.x, game.customerPosition.y - 35, 20, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Customer name with Greek styling
        ctx.fillStyle = '#F5DEB3';
        ctx.font = 'bold 12px Cinzel, serif';
        ctx.textAlign = 'center';
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 1;
        ctx.strokeText(game.currentCustomer.name, game.customerPosition.x, game.customerPosition.y + 55);
        ctx.fillText(game.currentCustomer.name, game.customerPosition.x, game.customerPosition.y + 55);
      }
    }
    
    // Ancient speech scroll helper
    function renderSpeechBubble(x, y, text) {
      const scrollWidth = Math.max(220, text.length * 9);
      const scrollHeight = 45;
      
      // Parchment scroll background
      ctx.fillStyle = 'rgba(245, 222, 179, 0.95)'; // Wheat/parchment with transparency
      ctx.strokeStyle = '#D2691E'; // Chocolate border
      ctx.lineWidth = 3;
      
      // Scroll shape with rounded ends
      ctx.beginPath();
      if (ctx.roundRect) {
        ctx.roundRect(x - scrollWidth/2, y - scrollHeight, scrollWidth, scrollHeight, 15);
      } else {
        // Fallback rectangle
        ctx.rect(x - scrollWidth/2, y - scrollHeight, scrollWidth, scrollHeight);
      }
      ctx.fill();
      ctx.stroke();
      
      // Scroll aging/burn marks
      ctx.fillStyle = 'rgba(139, 69, 19, 0.1)';
      ctx.fillRect(x - scrollWidth/2 + 5, y - scrollHeight + 5, scrollWidth - 10, scrollHeight - 10);
      
      // Inner scroll border
      ctx.strokeStyle = '#CD853F'; // Peru color
      ctx.lineWidth = 1;
      ctx.strokeRect(x - scrollWidth/2 + 4, y - scrollHeight + 4, scrollWidth - 8, scrollHeight - 8);
      
      // Scroll pointer (torn parchment effect)
      ctx.fillStyle = 'rgba(245, 222, 179, 0.95)';
      ctx.strokeStyle = '#D2691E';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x - 12, y);
      ctx.lineTo(x, y + 12);
      ctx.lineTo(x + 12, y);
      ctx.lineTo(x + 8, y - 3);
      ctx.lineTo(x - 8, y - 3);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Ancient script text
      ctx.fillStyle = '#8B4513'; // Saddle brown ink
      ctx.font = 'italic 14px Crimson Text, serif';
      ctx.textAlign = 'center';
      ctx.strokeStyle = '#654321';
      ctx.lineWidth = 0.3;
      ctx.strokeText(`"${text}"`, x, y - scrollHeight/2 + 8);
      ctx.fillText(`"${text}"`, x, y - scrollHeight/2 + 8);
    }
    
    // Render UI
    function renderUI() {
      // Transparent header with stone dungeon styling
      const headerGrad = ctx.createLinearGradient(0, 0, canvas.width, 120);
      headerGrad.addColorStop(0, 'rgba(74, 55, 40, 0.8)'); // Stone brown with transparency
      headerGrad.addColorStop(0.5, 'rgba(44, 24, 16, 0.9)'); // Dark brown  
      headerGrad.addColorStop(1, 'rgba(26, 13, 8, 0.95)'); // Very dark brown
      ctx.fillStyle = headerGrad;
      ctx.fillRect(0, 0, canvas.width, 120);
      
      // Ancient stone border with carved appearance
      ctx.strokeStyle = '#8B4513';
      ctx.lineWidth = 4;
      ctx.strokeRect(2, 2, canvas.width - 4, 116);
      
      // Inner carved border
      ctx.strokeStyle = '#A0522D';
      ctx.lineWidth = 2;
      ctx.strokeRect(6, 6, canvas.width - 12, 108);
      
      // Ancient score display (top-right)
      ctx.fillStyle = '#DAA520'; // Dark goldenrod
      ctx.font = 'bold 22px Cinzel, serif';
      ctx.textAlign = 'right';
      ctx.strokeStyle = '#654321';
      ctx.lineWidth = 2;
      ctx.strokeText(`Souls Served: ${game.score}/${CONFIG.WIN_SCORE}`, canvas.width - 20, 35);
      ctx.fillText(`Souls Served: ${game.score}/${CONFIG.WIN_SCORE}`, canvas.width - 20, 35);
      ctx.strokeText(`Trial Level: ${game.level}`, canvas.width - 20, 60);
      ctx.fillText(`Trial Level: ${game.level}`, canvas.width - 20, 60);
      
      // Enhanced timer with ancient hourglass styling
      if (game.currentRiddle) {
        ctx.textAlign = 'center';
        
        // Timer background - ancient hourglass shape
        const timerX = canvas.width/2;
        const timerY = 45;
        const hourglassWidth = 120;
        const hourglassHeight = 30;
        
        // Hourglass background
        ctx.fillStyle = 'rgba(139, 69, 19, 0.8)';
        ctx.fillRect(timerX - hourglassWidth/2, timerY - hourglassHeight/2, hourglassWidth, hourglassHeight);
        
        // Sand progress bar
        const timePercent = Math.max(0, game.timer / game.timePerRiddle);
        let sandColor;
        if (game.timer <= 5) {
          sandColor = '#DC143C'; // Crimson - danger
        } else if (game.timer <= 10) {
          sandColor = '#FF6347'; // Tomato - warning
        } else {
          sandColor = '#DAA520'; // Dark goldenrod - safe
        }
        
        // Animated sand
        const flickerSand = Math.sin(Date.now() * 0.01) * 0.1 + 0.9;
        ctx.fillStyle = sandColor;
        ctx.globalAlpha = flickerSand;
        ctx.fillRect(timerX - hourglassWidth/2 + 2, timerY - hourglassHeight/2 + 2, 
                    (hourglassWidth - 4) * timePercent, hourglassHeight - 4);
        ctx.globalAlpha = 1;
        
        // Hourglass border
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 3;
        ctx.strokeRect(timerX - hourglassWidth/2, timerY - hourglassHeight/2, hourglassWidth, hourglassHeight);
        
        // Timer text with ancient styling
        ctx.fillStyle = '#F5DEB3'; // Wheat
        ctx.font = 'bold 18px Cinzel, serif';
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 1;
        ctx.strokeText(`${Math.ceil(game.timer)}s`, timerX, timerY + 6);
        ctx.fillText(`${Math.ceil(game.timer)}s`, timerX, timerY + 6);
        
        // Urgent pulsing effect for low time
        if (game.timer <= 5) {
          const pulse = Math.sin(Date.now() * 0.02) * 0.3 + 0.7;
          ctx.shadowColor = '#DC143C';
          ctx.shadowBlur = 15 * pulse;
          ctx.strokeRect(timerX - hourglassWidth/2 - 5, timerY - hourglassHeight/2 - 5, 
                        hourglassWidth + 10, hourglassHeight + 10);
          ctx.shadowBlur = 0;
        }
      }
      
      // Enhanced riddle display with parchment styling
      if (game.currentRiddle) {
        const riddleY = 85;
        const riddleWidth = Math.min(800, game.currentRiddle.text.length * 12);
        
        // Parchment background for riddle
        ctx.fillStyle = 'rgba(245, 222, 179, 0.95)'; // Wheat with transparency
        ctx.fillRect(canvas.width/2 - riddleWidth/2, riddleY - 15, riddleWidth, 25);
        
        // Parchment border
        ctx.strokeStyle = '#D2691E';
        ctx.lineWidth = 2;
        ctx.strokeRect(canvas.width/2 - riddleWidth/2, riddleY - 15, riddleWidth, 25);
        
        // Riddle text with ancient styling
        ctx.fillStyle = '#8B4513'; // Saddle brown
        ctx.font = 'italic 18px Crimson Text, serif';
        ctx.textAlign = 'center';
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 0.5;
        ctx.strokeText(`"${game.currentRiddle.text}"`, canvas.width/2, riddleY);
        ctx.fillText(`"${game.currentRiddle.text}"`, canvas.width/2, riddleY);
      }
      
      // Customer and message - Phase 2
      if (game.currentCustomer) {
        ctx.fillStyle = '#FFD700';
        ctx.font = '16px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(game.currentCustomer.name, 20, 35);
        
        if (game.customerMessage && game.messageTimer > 0) {
          ctx.fillStyle = 'white';
          ctx.font = '14px Arial';
          ctx.fillText(`"${game.customerMessage}"`, 20, 55);
        }
      }
      
      // Debug zone info (if debug mode)
      if (game.debugMode) {
        ctx.fillStyle = '#0F0';
        ctx.font = '12px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`Zone: ${game.player.currentZone || 'none'}`, 20, 85);
        if (game.player.carrying) {
          ctx.fillText(`Carrying: ${game.player.carrying}`, 20, 105);
        }
      }
      
      // Plate contents (below table)
      if (game.plate.length > 0) {
        ctx.fillStyle = 'white';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`Plate: ${game.plate.join(', ')}`, 
                     KITCHEN.POSITIONS.TABLE.x, 
                     KITCHEN.POSITIONS.TABLE.y + 100);
      }
      
      // Toast message (center)
      if (game.toastMessage && game.toastTimer > 0) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        const width = ctx.measureText(game.toastMessage).width + 40;
        ctx.fillRect(canvas.width/2 - width/2, canvas.height/2 - 30, width, 60);
        
        ctx.fillStyle = 'white';
        ctx.font = '18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(game.toastMessage, canvas.width/2, canvas.height/2);
      }
      
      // Controls (bottom)
      ctx.fillStyle = '#AAA';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('WASD: Move | E: Pickup/Place | Q: Undo | X: Trash | Enter: Deliver | ~: Debug',
                   canvas.width/2, canvas.height - 10);
      
      // FPS counter (debug)
      if (game.debugMode) {
        ctx.fillStyle = '#0F0';
        ctx.font = '14px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`FPS: ${game.currentFPS}`, 20, canvas.height - 40);
      }
    }
    
    // Menu screen
    function renderMenu() {
      // Dark stone dungeon background with torchlight
      const bgGrad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, 
                                              canvas.width/2, canvas.height/2, canvas.width);
      bgGrad.addColorStop(0, '#4A3728'); // Stone brown
      bgGrad.addColorStop(0.7, '#2C1810'); // Dark brown
      bgGrad.addColorStop(1, '#0A0A0A'); // Black void
      ctx.fillStyle = bgGrad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Add stone texture overlay
      ctx.fillStyle = 'rgba(139, 69, 19, 0.1)';
      for (let i = 0; i < 50; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        ctx.fillRect(x, y, 2, 2);
      }
      
      // Torchlight flickering effect
      const flicker = Math.sin(Date.now() * 0.01) * 0.1 + 0.9;
      const torchGrad = ctx.createRadialGradient(canvas.width/2, 50, 0, 
                                                 canvas.width/2, 50, 400);
      torchGrad.addColorStop(0, `rgba(255, 140, 0, ${0.3 * flicker})`);
      torchGrad.addColorStop(1, 'rgba(255, 140, 0, 0)');
      ctx.fillStyle = torchGrad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Main title with ancient Greek styling
      ctx.fillStyle = '#DAA520'; // Dark goldenrod
      ctx.font = 'bold 52px Cinzel, serif';
      ctx.textAlign = 'center';
      ctx.strokeStyle = '#8B4513';
      ctx.lineWidth = 3;
      ctx.strokeText('ORDER OF THE GODS', canvas.width/2, 140);
      ctx.fillText('ORDER OF THE GODS', canvas.width/2, 140);
      
      // Subtitle - Dungeon location
      ctx.fillStyle = '#CD853F'; // Peru color
      ctx.font = 'italic 24px Cinzel, serif';
      ctx.strokeStyle = '#654321';
      ctx.lineWidth = 2;
      ctx.strokeText('Dungeon of Mount Olympus', canvas.width/2, 180);
      ctx.fillText('Dungeon of Mount Olympus', canvas.width/2, 180);
      
      // Prisoner backstory - formatted nicely
      const storyLines = [
        "You are no master chef. You are a prisoner.",
        "",
        "An iron collar bites your neck, its chain dragging you into the Feast Hall",
        "of Eternity‚Äîa torchlit kitchen suspended between Olympus and the mortal world.",
        "",
        "Each night, gods, monsters, and restless spirits gather not to feast,",
        "but to watch you struggle with their riddles.",
        "",
        "Guess wrong, and you are mocked. Serve slow, and you are punished.",
        "The collar loosens with each dish served well... but never falls away.",
        "",
        "You are their servant. Their spectacle. Their captive."
      ];
      
      ctx.fillStyle = '#F5DEB3'; // Wheat color for readable text
      ctx.font = '16px Crimson Text, serif';
      ctx.textAlign = 'center';
      
      let yPos = 230;
      storyLines.forEach((line, index) => {
        if (line === "") {
          yPos += 10; // Smaller spacing for empty lines
        } else {
          // Add subtle shadow for readability
          ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
          ctx.fillText(line, canvas.width/2 + 1, yPos + 1);
          ctx.fillStyle = '#F5DEB3';
          ctx.fillText(line, canvas.width/2, yPos);
          yPos += 20;
        }
      });
      
      // Start prompt with ancient styling
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 28px Cinzel, serif';
      ctx.strokeStyle = '#B8860B';
      ctx.lineWidth = 2;
      ctx.strokeText('Press ENTER to Begin Your Trial', canvas.width/2, yPos + 40);
      ctx.fillText('Press ENTER to Begin Your Trial', canvas.width/2, yPos + 40);
      
      // Controls hint
      ctx.fillStyle = '#CD853F';
      ctx.font = '14px Crimson Text, serif';
      ctx.fillText('WASD: Move | E: Interact | Q: Undo | X: Trash | Enter: Deliver', canvas.width/2, yPos + 80);
      
      // Check for enter key to start
      if (input.wasPressed('enter')) {
        startGame();
      }
    }
    
    // Win screen
    function renderWinScreen() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 64px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('PHASE 1 COMPLETE!', canvas.width/2, 250);
      
      ctx.fillStyle = 'white';
      ctx.font = '32px Arial';
      ctx.fillText(`Final Score: ${game.score} points`, canvas.width/2, 350);
      
      ctx.font = '24px Arial';
      ctx.fillText('Core mechanics working!', canvas.width/2, 420);
      
      ctx.font = '32px Arial';
      ctx.fillText('Press ENTER to Restart', canvas.width/2, 520);
      
      // Check for restart
      if (input.wasPressed('enter')) {
        location.reload(); // Simple restart
      }
    }
    
    // Pause overlay
    function renderPauseOverlay() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.fillStyle = 'white';
      ctx.font = 'bold 48px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
      
      ctx.font = '24px Arial';
      ctx.fillText('Press ESC to Resume', canvas.width/2, canvas.height/2 + 50);
    }
    
    // Debug info
    function renderDebug() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillRect(10, 100, 300, 200);
      
      ctx.fillStyle = '#0F0';
      ctx.font = '12px monospace';
      ctx.textAlign = 'left';
      
      const info = [
        `Player: (${Math.round(game.player.x)}, ${Math.round(game.player.y)})`,
        `Zone: ${game.player.currentZone || 'none'}`,
        `Carrying: ${game.player.carrying || 'none'}`,
        `Plate: [${game.plate.join(', ')}]`,
        `State: ${game.state}`,
        `Score: ${game.score}/${CONFIG.WIN_SCORE} (Level ${game.level})`,
        `Timer: ${game.timer ? game.timer.toFixed(1) + 's' : 'none'}`,
        `Riddle: ${game.currentRiddle ? game.currentRiddle.id : 'none'}`,
        `Type: ${game.currentRiddle ? game.currentRiddle.type : 'none'}`,
        `Customer: ${game.currentCustomer ? game.currentCustomer.name : 'none'}`,
        `FPS: ${game.currentFPS}`,
        '',
        'Debug Commands (Console):',
        'debug.nextRiddle()',
        'debug.solveRiddle()',
        'debug.skipToLevel(2/3)',
        'debug.addScore(10)'
      ];
      
      info.forEach((line, i) => {
        ctx.fillText(line, 15, 120 + i * 15);
      });
      
      // Show hitboxes if enabled
      if (game.showHitboxes) {
        // Table zone
        ctx.strokeStyle = 'lime';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(KITCHEN.POSITIONS.TABLE.x, KITCHEN.POSITIONS.TABLE.y,
                KITCHEN.ZONES.TABLE_RADIUS, 0, Math.PI * 2);
        ctx.stroke();
        
        // Trash zone
        ctx.beginPath();
        ctx.arc(KITCHEN.POSITIONS.TRASH.x, KITCHEN.POSITIONS.TRASH.y,
                KITCHEN.ZONES.TRASH_RADIUS, 0, Math.PI * 2);
        ctx.stroke();
        
        // Bin zones
        for (let pos of Object.values(KITCHEN.POSITIONS.BINS)) {
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, KITCHEN.ZONES.BIN_RADIUS, 0, Math.PI * 2);
          ctx.stroke();
        }
        
        // Counter zone
        const counter = KITCHEN.POSITIONS.COUNTER;
        ctx.strokeRect(counter.x - KITCHEN.ZONES.COUNTER_WIDTH/2,
                      counter.y - KITCHEN.ZONES.COUNTER_HEIGHT/2 - 30,
                      KITCHEN.ZONES.COUNTER_WIDTH,
                      KITCHEN.ZONES.COUNTER_HEIGHT + 60);
      }
    }
    
    // Main render function
    function render() {
      // Ensure optimal render quality every frame
      ensureRenderQuality();
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw based on game state
      if (game.state === 'menu') {
        renderMenu();
      } else if (game.state === 'playing' || game.state === 'paused') {
        renderKitchen();
        renderCustomers(); // Phase 3 - Render customer sprites
        renderPlayer();
        renderUI();
        if (game.state === 'paused') {
          renderPauseOverlay();
        }
      } else if (game.state === 'won') {
        renderWinScreen();
      }
      
      // Debug info
      if (game.debugMode) {
        renderDebug();
      }
    }
    
    // =============================================================================
    // GAME LOOP & UPDATE
    // =============================================================================
    
    // Main update function
    function update(deltaTime) {
      if (game.state !== 'playing') return;
      
      // Update timer (Phase 2)
      if (game.currentRiddle) {
        game.timer -= deltaTime / 1000;
        if (game.timer <= 0) {
          game.timer = 0;
          // Clean timeout handling - simple transition, no scramble
          game.customerMessage = "TIMED OUT!!!";
          game.messageTimer = 2000;
          showToast("TIMED OUT!!!");
          console.log("TIMEOUT! Simple transition to next customer...");
          AUDIO.playTimeout(); // Audio feedback
          game.plate = []; // Clear plate
          
          // Simple customer transition - NO SCRAMBLING
          game.customerState = 'walking_out';
          setTimeout(() => {
            // Simple ordered progression - no re-shuffling on timeout
            game.customerIndex++;
            if (game.customerIndex >= game.shuffledCustomers.length) {
              game.customerIndex = 0; // Loop back to start of shuffled list
            }
            game.currentCustomer = game.shuffledCustomers[game.customerIndex];
            
            // Get next riddle for this customer
            const levelRiddles = RIDDLES.filter(r => r.level === game.level);
            const available = levelRiddles.filter(r => !game.usedRiddles.includes(r.id));
            
            if (available.length === 0) {
              game.usedRiddles = [];
              game.currentRiddle = randomChoice(levelRiddles);
            } else {
              game.currentRiddle = randomChoice(available);
            }
            
            game.usedRiddles.push(game.currentRiddle.id);
            game.timer = game.timePerRiddle;
            
            // Apply time bonus for cooking riddles after timeout too
            if (game.currentRiddle.timeBonus) {
              game.timer += game.currentRiddle.timeBonus;
              console.log(`‚è∞ Added ${game.currentRiddle.timeBonus}s bonus time for cooking/cutting riddle (timeout)`);
            }
            game.customerMessage = '';
            game.messageTimer = 0;
            
            // Reset customer animation cleanly
            game.customerState = 'walking_in';
            game.customerPosition.x = KITCHEN.CUSTOMER_AREA.LEFT;
            game.customerPosition.y = KITCHEN.CUSTOMER_AREA.ENTRANCE_Y;
            game.customerAnimation = 0;
            
            console.log(`üé≠ Next customer: ${game.currentCustomer.name} (index: ${game.customerIndex}) with riddle: ${game.currentRiddle.text.substring(0, 30)}...`);
          }, 2500); // Give time for walking animation
        }
      }
      
      // Update player
      updatePlayer(deltaTime);
      
      // Update customer animation (Phase 5)
      updateCustomerAnimation(deltaTime);
      
      // Handle input
      if (input.wasPressed('e')) {
        handleInteraction();
      }
      
      if (input.wasPressed('q')) {
        handleUndo();
      }
      
      if (input.wasPressed('x')) {
        handleTrash();
      }
      
      if (input.wasPressed('enter')) {
        handleDelivery();
      }
      
      if (input.wasPressed('v')) {
        handleOvenRetrieve();
      }
      
      // Update timers
      if (game.toastTimer > 0) {
        game.toastTimer -= deltaTime;
      }
      if (game.messageTimer > 0) {
        game.messageTimer -= deltaTime;
      }
      if (game.deliveryDebounce > 0) {
        game.deliveryDebounce -= deltaTime;
      }
      
      // Update cooking timer
      if (game.cookingTimer > 0) {
        game.cookingTimer -= deltaTime;
        if (game.cookingTimer <= 0) {
          game.cookingTimer = 0;
          if (game.cookingItem) {
            showToast(`${game.cookingItem} finished cooking! Press V to retrieve`);
            AUDIO.playSuccess(); // Sound when cooking completes
          }
        }
      }
    }
    
    // FPS calculation
    function updateFPS(currentTime) {
      game.frameCount++;
      if (currentTime - game.lastFPSTime >= 1000) {
        game.currentFPS = game.frameCount;
        game.frameCount = 0;
        game.lastFPSTime = currentTime;
      }
    }
    
    // Main game loop
    function gameLoop(currentTime) {
      const deltaTime = currentTime - game.lastTime;
      game.lastTime = currentTime;
      
      // Update FPS
      updateFPS(currentTime);
      
      // Skip huge deltas (first frame, tab switch)
      if (deltaTime < 100) {
        update(deltaTime);
      }
      
      render();
      requestAnimationFrame(gameLoop);
    }
    
    // =============================================================================
    // GAME INITIALIZATION
    // =============================================================================
    
    // Start the game
    function startGame() {
      game.state = 'playing';
      game.score = 0;
      game.level = 1;
      game.timePerRiddle = CONFIG.LEVEL_1_TIME;
      game.plate = [];
      game.usedRiddles = [];
      game.customerIndex = 0;
      game.shuffledCustomers = shuffleCustomers(); // Randomize customer order each game
      game.player.carrying = null;
      
      // Get first riddle
      nextRiddle();
      
      console.log('üèõÔ∏è Order of the Gods - Dungeon of Mount Olympus trial begins!');
      showToast("The iron collar tightens... Your trial in the Feast Hall begins!");
    }
    
    // Initialize everything
    async function init() {
      console.log('üèõÔ∏è Initializing Order of the Gods - Dungeon of Mount Olympus...');
      
      // Check for mobile/small screen (updated for fullscreen experience)
      if (window.innerWidth < 1200 || window.innerHeight < 600) {
        document.querySelector('.mobile-warning').style.display = 'block';
        canvas.style.display = 'none';
        console.log('‚ùå Screen too small for fullscreen experience - game blocked');
        return;
      }
      
      // Load Phase 3 assets
      try {
        await loadAssets();
        console.log('üé® All assets loaded successfully!');
      } catch (error) {
        console.log('‚ö†Ô∏è Some assets failed to load, using fallbacks');
      }
      
      // Initialize input
      input.init();
      
      // Initialize audio system
      AUDIO.init();
      
      // Start at menu
      game.state = 'menu';
      
      // Debug commands (Phase 2)
      window.debug = {
        showState: () => console.log(game),
        addScore: (n) => { 
          game.score += n; 
          updateLevel();
          console.log(`Score: ${game.score}, Level: ${game.level}`); 
        },
        teleport: (x, y) => { 
          game.player.x = x; 
          game.player.y = y; 
          console.log(`Teleported to ${x}, ${y}`);
        },
        testCorners: () => {
          const corners = [
            { x: KITCHEN.BOUNDS.LEFT + 20, y: KITCHEN.BOUNDS.TOP + 20 },
            { x: KITCHEN.BOUNDS.RIGHT - 20, y: KITCHEN.BOUNDS.TOP + 20 },
            { x: KITCHEN.BOUNDS.LEFT + 20, y: KITCHEN.BOUNDS.BOTTOM - 20 },
            { x: KITCHEN.BOUNDS.RIGHT - 20, y: KITCHEN.BOUNDS.BOTTOM - 20 }
          ];
          
          let i = 0;
          const interval = setInterval(() => {
            if (i >= corners.length) {
              clearInterval(interval);
              debug.teleport(640, 360); // Return to center
              return;
            }
            debug.teleport(corners[i].x, corners[i].y);
            i++;
          }, 1000);
        },
        nextRiddle: () => { nextRiddle(); console.log('Skipped to next riddle'); },
        skipToLevel: (level) => {
          if (level === 2) debug.addScore(CONFIG.LEVEL_2_SCORE);
          else if (level === 3) debug.addScore(CONFIG.LEVEL_3_SCORE);
          else console.log('Level must be 2 or 3');
        },
        setTimer: (seconds) => { game.timer = seconds; console.log(`Timer set to ${seconds}s`); },
        solveRiddle: () => {
          if (!game.currentRiddle) return;
          // Auto-solve current riddle
          game.plate = [];
          if (game.currentRiddle.type === 'COUNT') {
            for (let [ingredient, count] of Object.entries(game.currentRiddle.counts)) {
              for (let i = 0; i < count; i++) {
                game.plate.push(ingredient);
              }
            }
          } else if (game.currentRiddle.type === 'SANDWICH') {
            game.plate = [...game.currentRiddle.sandwich];
          }
          console.log('Auto-solved riddle:', game.plate);
        },
        toggleAudio: () => { 
          AUDIO.enabled = !AUDIO.enabled; 
          console.log(`Audio ${AUDIO.enabled ? 'enabled' : 'disabled'}`);
        },
        win: () => { game.score = CONFIG.WIN_SCORE; game.state = 'won'; },
        start: () => startGame()
      };
      
      // Start game loop
      game.lastTime = performance.now();
      game.lastFPSTime = performance.now();
      requestAnimationFrame(gameLoop);
      
      console.log('‚úÖ Dungeon of Mount Olympus initialized! Press ENTER to begin your trial.');
      console.log('üí° Divine commands: debug.nextRiddle(), debug.solveRiddle(), debug.toggleAudio(), etc.');
      console.log('üèõÔ∏è Mythological features: Greek fonts, Crate storage, Walking gods & spirits!');
      console.log('‚ö±Ô∏è Ancient styling: Torchlight effects, Parchment riddles, Stone carvings!');
    }
    
    // Handle window resize for fullscreen experience - SIMPLE AND WORKING
    function handleResize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      // Re-apply high-quality image settings after resize
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      
      // Update dynamic positions
      KITCHEN.BOUNDS.RIGHT = window.innerWidth - 80;
      KITCHEN.BOUNDS.BOTTOM = window.innerHeight - 80;
      KITCHEN.CUSTOMER_AREA.BOTTOM = window.innerHeight - 80;
      KITCHEN.CUSTOMER_AREA.EXIT_Y = window.innerHeight - 100;
      KITCHEN.POSITIONS.TRASH.x = window.innerWidth - 150;
      KITCHEN.POSITIONS.TRASH.y = window.innerHeight - 150;
      KITCHEN.POSITIONS.COUNTER.x = Math.max(640, window.innerWidth * 0.5);
      KITCHEN.POSITIONS.TABLE.x = Math.max(640, window.innerWidth * 0.5);
      KITCHEN.POSITIONS.TABLE.y = Math.max(360, window.innerHeight * 0.4);
      KITCHEN.POSITIONS.BINS.cheese.x = window.innerWidth - 160;
      KITCHEN.POSITIONS.BINS.meat.x = window.innerWidth - 160;
      KITCHEN.POSITIONS.BINS.egg.x = Math.max(530, window.innerWidth * 0.4);
      KITCHEN.POSITIONS.BINS.egg.y = window.innerHeight - 180;
      KITCHEN.POSITIONS.BINS.pepper.x = Math.max(850, window.innerWidth * 0.6);
      KITCHEN.POSITIONS.BINS.pepper.y = window.innerHeight - 180;
      KITCHEN.POSITIONS.CUTTING_BOARD.x = window.innerWidth - 250;
      
      console.log(`üñ•Ô∏è Canvas resized to: ${canvas.width}x${canvas.height} - positioning fixed`);
    }
    
    // Start when page loads
    window.addEventListener('load', init);
    window.addEventListener('resize', handleResize);
    
  </script>
</body>
</html>
