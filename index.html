<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Order of the Gods - Dungeon of Mount Olympus</title>
  <!-- Google Fonts for Greek Mythological Styling -->
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap" rel="stylesheet">
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #000;
      font-family: Arial, sans-serif;
      overflow: hidden; /* Prevent scrollbars */
      width: 100vw;
      height: 100vh;
    }
    canvas {
      display: block;
      background: #1a1a1a;
      cursor: none; /* Hide mouse cursor */
      width: 100vw;
      height: 100vh;
    }
    .mobile-warning {
      display: none;
      color: white;
      text-align: center;
      padding: 20px;
      font-size: 24px;
    }
    /* Block mobile and small screens - updated for fullscreen */
    @media (max-width: 1200px), (max-height: 600px) {
      canvas { display: none !important; }
      .mobile-warning { display: block !important; }
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <div class="mobile-warning">
    <h2>üñ•Ô∏è Laptop + Keyboard Required</h2>
    <p>This game requires a laptop or desktop computer with keyboard controls.</p>
    <p>WASD keys required for movement.</p>
  </div>

  <script>
    // =============================================================================
    // ORDER OF THE GODS - PHASE 1 IMPLEMENTATION
    // =============================================================================
    
    console.log("üèõÔ∏è Order of the Gods - Starting Phase 1...");
    
    // Get canvas and context - FULLSCREEN SETUP
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Set canvas to full screen dimensions
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // Verify canvas support
    if (!ctx) {
      alert('Your browser does not support Canvas. Please use Chrome, Firefox, or Safari.');
      throw new Error('Canvas not supported');
    }
    
    console.log(`‚úÖ Canvas initialized: ${canvas.width}x${canvas.height}`);
    
    // =============================================================================
    // CONSTANTS & CONFIGURATION
    // =============================================================================
    
    // EXACT KITCHEN LAYOUT COORDINATES (DO NOT CHANGE)
    const KITCHEN = {
      BOUNDS: {
        LEFT: 280,    // Kitchen area starts further right to make room for customers
        RIGHT: window.innerWidth - 80, // Dynamic based on screen width 
        TOP: 80,
        BOTTOM: window.innerHeight - 80 // Dynamic based on screen height
      },
      CUSTOMER_AREA: {
        LEFT: 50,     // Customer walking/waiting area
        RIGHT: 270,    
        TOP: 160,     // Below header (120px + sprite height buffer)
        BOTTOM: window.innerHeight - 80, // Dynamic based on screen height
        QUEUE_X: 200, // Where customers line up
        ENTRANCE_Y: 240, // Where customers enter from (adjusted for larger 128px sprites)
        EXIT_Y: window.innerHeight - 100   // Where customers exit to (near bottom)
      },
      POSITIONS: {
        COUNTER: { x: Math.max(640, window.innerWidth * 0.5), y: 200 },     // Centered delivery counter (responsive)
        TABLE: { x: Math.max(640, window.innerWidth * 0.5), y: Math.max(360, window.innerHeight * 0.4) },       // Central plate assembly (responsive)
        TRASH: { x: window.innerWidth - 150, y: window.innerHeight - 150 }, // Trash bin - bottom right corner (responsive)
        BINS: {
          bread: { x: 360, y: 260 },     // Left side bins
          tomato: { x: 360, y: 460 },    
          cheese: { x: window.innerWidth - 160, y: 260 },   // Right side bins (responsive)
          meat: { x: window.innerWidth - 160, y: 460 },     
          egg: { x: Math.max(530, window.innerWidth * 0.4), y: window.innerHeight - 180 },       // Bottom bins (responsive)
          pepper: { x: Math.max(850, window.innerWidth * 0.6), y: window.innerHeight - 180 }     
        }
      },
      ZONES: {
        TABLE_RADIUS: 90,        // Distance to interact with table
        BIN_RADIUS: 60,          // Distance to interact with bins
        TRASH_RADIUS: 50,        // Distance to interact with trash
        COUNTER_WIDTH: 360,      // Width of delivery zone
        COUNTER_HEIGHT: 40,      // Height of delivery zone
        INTERACTION_BUFFER: 8    // Extra pixels for generous collision
      }
    };
    
    // Game configuration
    const CONFIG = {
      PLAYER_SPEED: 5,           // Pixels per frame (300 px/sec at 60fps)
      PLAYER_SIZE: 32,           // Player square size
      MAX_PLATE_SIZE: 5,         // Maximum ingredients on plate
      MAX_CARRY: 1,              // Can only carry one ingredient
      
      // Timing
      LEVEL_1_TIME: 22,          // Seconds per riddle (level 1)
      LEVEL_2_TIME: 18,          // Seconds per riddle (level 2)
      LEVEL_3_TIME: 15,          // Seconds per riddle (level 3)
      
      // Progression
      LEVEL_2_SCORE: 10,         // Score needed for level 2
      LEVEL_3_SCORE: 20,         // Score needed for level 3
      WIN_SCORE: 30,             // Score needed to win
      
      // Visual
      COLORS: {
        PLAYER: '#FFD700',       // Gold
        BREAD: '#DEB887',        // Burlywood
        TOMATO: '#FF6347',       // Tomato red
        CHEESE: '#FFD700',       // Gold
        MEAT: '#8B0000',         // Dark red
        EGG: '#FFFACD',          // Lemon chiffon
        PEPPER: '#FF4500',       // Orange red
        TABLE: '#8B4513',        // Saddle brown
        COUNTER: '#696969',      // Dim gray
        WALL: '#4a4a4a',         // Gray
        FLOOR: '#2a2a2a'         // Dark gray
      }
    };
    
    console.log("‚úÖ Configuration loaded");
    
    // =============================================================================
    // ASSET LOADING SYSTEM (PHASE 3)
    // =============================================================================
    
    // Asset mapping and loading
    const ASSETS = {
      ingredients: {},
      customers: {},
      ui: {},
      loaded: false,
      totalAssets: 0,
      loadedAssets: 0
    };
    
    // Asset file mapping
    const ASSET_FILES = {
      ingredients: {
        bread: 'assets/bread.png',
        tomato: 'assets/tomato.png', 
        cheese: 'assets/cheese.png',
        meat: 'assets/meat.png',  // Updated to use meat.png
        egg: 'assets/egg.png',     // New egg asset!
        pepper: 'assets/pepper.png'
      },
      customers: {
        medusa: 'assets/medusa.png',
        minotaur: 'assets/minotaur.png',
        hermes: 'assets/hermes.png',
        sphinx: 'assets/sphinx.png',
        pegasus: 'assets/pegasus.png',
        poseidon: 'assets/poseidon.png',  // God of the sea
        ghost: 'assets/restless-spirit.png'  // New restless spirit asset!
      },
      ui: {
        plate: 'assets/plate.png',
        crate: 'assets/crate.png'
      },
      player: {
        character: 'assets/main character.png'  // New player character sprite!
      }
    };
    
    // Load image helper
    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          ASSETS.loadedAssets++;
          console.log(`‚úÖ Loaded: ${src} (${ASSETS.loadedAssets}/${ASSETS.totalAssets})`);
          resolve(img);
        };
        img.onerror = () => {
          ASSETS.loadedAssets++;
          console.log(`‚ùå Failed: ${src}`);
          reject(new Error(`Failed to load ${src}`));
        };
        img.src = src;
      });
    }
    
    // Load all assets
    async function loadAssets() {
      console.log('üé® Loading Phase 3 assets...');
      
      const loadPromises = [];
      
      // Count total assets
      Object.values(ASSET_FILES.ingredients).forEach(src => src && ASSETS.totalAssets++);
      Object.values(ASSET_FILES.customers).forEach(src => src && ASSETS.totalAssets++);
      Object.values(ASSET_FILES.ui).forEach(src => src && ASSETS.totalAssets++);
      
      // Load ingredient assets
      for (let [ingredient, src] of Object.entries(ASSET_FILES.ingredients)) {
        if (src) {
          loadPromises.push(
            loadImage(src).then(img => {
              ASSETS.ingredients[ingredient] = img;
            }).catch(() => {
              console.log(`‚ö†Ô∏è Using fallback for ${ingredient}`);
              ASSETS.ingredients[ingredient] = null;
            })
          );
        } else {
          ASSETS.ingredients[ingredient] = null; // Will use fallback rendering
        }
      }
      
      // Load customer assets
      for (let [customer, src] of Object.entries(ASSET_FILES.customers)) {
        if (src) {
          loadPromises.push(
            loadImage(src).then(img => {
              ASSETS.customers[customer] = img;
            }).catch(() => {
              ASSETS.customers[customer] = null;
            })
          );
        }
      }
      
      // Load UI assets
      for (let [ui, src] of Object.entries(ASSET_FILES.ui)) {
        if (src) {
          loadPromises.push(
            loadImage(src).then(img => {
              ASSETS.ui[ui] = img;
            }).catch(() => {
              ASSETS.ui[ui] = null;
            })
          );
        }
      }
      
      // Wait for all assets to load
      await Promise.allSettled(loadPromises);
      
      ASSETS.loaded = true;
      console.log(`üé® Phase 3 assets loaded: ${ASSETS.loadedAssets}/${ASSETS.totalAssets}`);
      
      return ASSETS.loaded;
    }
    
    console.log("‚úÖ Asset system initialized");
    
    // =============================================================================
    // AUDIO SYSTEM (PHASE 3)
    // =============================================================================
    
    // Audio context and sound effects
    const AUDIO = {
      context: null,
      enabled: true,
      sounds: {},
      
      // Initialize audio context
      init() {
        try {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
          console.log('üîä Audio system initialized');
        } catch (error) {
          console.log('‚ö†Ô∏è Audio not supported');
          this.enabled = false;
        }
      },
      
      // Create a simple beep sound
      createBeep(frequency, duration, type = 'sine') {
        if (!this.enabled || !this.context) return;
        
        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);
        
        oscillator.frequency.value = frequency;
        oscillator.type = type;
        
        gainNode.gain.setValueAtTime(0.1, this.context.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);
        
        oscillator.start(this.context.currentTime);
        oscillator.stop(this.context.currentTime + duration);
      },
      
      // Play different sound effects
      playPickup() {
        this.createBeep(800, 0.1, 'square');
      },
      
      playPlace() {
        this.createBeep(600, 0.15, 'sine');
      },
      
      playDelivery() {
        this.createBeep(1000, 0.3, 'sine');
      },
      
      playSuccess() {
        // Success chord
        setTimeout(() => this.createBeep(523, 0.2), 0);   // C
        setTimeout(() => this.createBeep(659, 0.2), 100); // E
        setTimeout(() => this.createBeep(784, 0.3), 200); // G
      },
      
      playFailure() {
        this.createBeep(200, 0.5, 'sawtooth');
      },
      
      playTimeout() {
        // Timeout warning
        this.createBeep(400, 0.3, 'triangle');
        setTimeout(() => this.createBeep(300, 0.3), 150);
      },
      
      playLevelUp() {
        // Level up fanfare
        const notes = [523, 659, 784, 1047]; // C, E, G, C octave
        notes.forEach((freq, i) => {
          setTimeout(() => this.createBeep(freq, 0.2), i * 100);
        });
      },
      
      playTrash() {
        this.createBeep(300, 0.2, 'sawtooth');
      }
    };
    
    console.log("‚úÖ Audio system configured");
    
    // =============================================================================
    // RIDDLE & CUSTOMER DATABASE (PHASE 2)
    // =============================================================================
    
    // All riddles for the game
    const RIDDLES = [
      // LEVEL 1 - Simple COUNT riddles (22 seconds)
      { id: "l1_1", text: "Golden grain blessed by Demeter with vine's crimson blood", type: "COUNT", level: 1, 
        counts: { bread: 1, tomato: 1 }},
      { id: "l1_2", text: "Hunter's prize paired with the cow's sacred gift", type: "COUNT", level: 1,
        counts: { meat: 1, cheese: 1 }},
      { id: "l1_3", text: "Zeus's forbidden treasure touched by flame's essence", type: "COUNT", level: 1,
        counts: { egg: 1, pepper: 1 }},
      { id: "l1_4", text: "Twin grains with single crimson orb", type: "COUNT", level: 1,
        counts: { bread: 2, tomato: 1 }},
      { id: "l1_5", text: "Double moon's gift crowning the beast", type: "COUNT", level: 1,
        counts: { cheese: 2, meat: 1 }},
      { id: "l1_6", text: "Sacred envelope: grain embraces cow's craft", type: "SANDWICH", level: 1,
        sandwich: ["bread", "cheese", "bread"]},
      { id: "l1_7", text: "Divine cradle: bread shelters vine's blood", type: "SANDWICH", level: 1,
        sandwich: ["bread", "tomato", "bread"]},
      { id: "l1_8", text: "Trinity of lunar discs", type: "COUNT", level: 1,
        counts: { cheese: 3 }},
      
      // LEVEL 2 - Divine EXCLUDE riddles (18 seconds)
      { id: "l2_1", text: "Blood and beast unite, but Zeus's egg brings doom", type: "EXCLUDE", level: 2,
        counts: { tomato: 1, meat: 1 }, exclude: ["egg"]},
      { id: "l2_2", text: "Double hunter's bounty, but moon's gift is forbidden", type: "EXCLUDE", level: 2,
        counts: { meat: 2 }, exclude: ["cheese"]},
      { id: "l2_3", text: "Fire and moon collide, but crimson blood is cursed", type: "EXCLUDE", level: 2,
        counts: { cheese: 1, pepper: 1 }, exclude: ["tomato"]},
      { id: "l2_4", text: "Twin lunar gifts blessing single crimson orb", type: "COUNT", level: 2,
        counts: { cheese: 2, tomato: 1 }},
      { id: "l2_5", text: "Warrior's meal: grain shields the hunter's prize", type: "SANDWICH", level: 2,
        sandwich: ["bread", "meat", "bread"]},
      { id: "l2_6", text: "Trio of vine's sacred blood", type: "COUNT", level: 2,
        counts: { tomato: 3 }},
      
      // LEVEL 3 - Legendary challenges (15 seconds)
      { id: "l3_1", text: "Trinity of power: grain, beast, crimson blood", type: "COUNT", level: 3,
        counts: { bread: 1, meat: 1, tomato: 1 }},
      { id: "l3_2", text: "Sacred triad: hunter's prize, moon's gift, flame's kiss", type: "COUNT", level: 3,
        counts: { meat: 1, cheese: 1, pepper: 1 }},
      { id: "l3_3", text: "Twin moons reign supreme, but fire is banished", type: "EXCLUDE", level: 3,
        counts: { cheese: 2 }, exclude: ["pepper"]},
      { id: "l3_4", text: "Inferno trapped in golden walls", type: "SANDWICH", level: 3,
        sandwich: ["bread", "pepper", "bread"]},
      { id: "l3_5", text: "Double beast blessing single flame", type: "COUNT", level: 3,
        counts: { meat: 2, pepper: 1 }},
      { id: "l3_6", text: "Hermes' perfect harmony: grain, blood, moon, beast", type: "COUNT", level: 3,
        counts: { bread: 1, tomato: 1, cheese: 1, meat: 1 }},
      { id: "l3_7", text: "Fill the divine plate completely with five sacred offerings", type: "TOTALCOUNT", level: 3,
        totalCount: 5},
      { id: "l3_8", text: "Medusa's challenge: All different, nothing repeated", type: "UNIQUE", level: 3,
        totalCount: 4, uniqueOnly: true},
      
      // ADDITIONAL LEVEL 1 RIDDLES - More variety for beginners
      { id: "l1_9", text: "The baker's foundation and Zeus's sacred creation", type: "COUNT", level: 1,
        counts: { bread: 1, egg: 1 }},
      { id: "l1_10", text: "Fire's kiss meets the earth's spice", type: "COUNT", level: 1,
        counts: { pepper: 2 }},
      { id: "l1_11", text: "Three gifts from Demeter's golden fields", type: "COUNT", level: 1,
        counts: { bread: 3 }},
      { id: "l1_12", text: "The vine's blood with fire's burn", type: "COUNT", level: 1,
        counts: { tomato: 1, pepper: 1 }},
      
      // ADDITIONAL LEVEL 2 RIDDLES - More complex combinations
      { id: "l2_9", text: "The feast of plenty, but no hunter's prize shall touch", type: "EXCLUDE", level: 2,
        totalCount: 4, excludes: ["meat"]},
      { id: "l2_10", text: "Sacred offerings abound, yet avoid Zeus's creation", type: "EXCLUDE", level: 2,
        totalCount: 3, excludes: ["egg"]},
      { id: "l2_11", text: "The forest's bread wrapped around earth's fire", type: "SANDWICH", level: 2,
        bread: true, filling: ["pepper"]},
      { id: "l2_12", text: "Golden grain embraces the hunter's prize with sacred gift", type: "SANDWICH", level: 2,
        bread: true, filling: ["meat", "cheese"]},
      { id: "l2_13", text: "Fill the sacred vessel, but let no vine's blood flow", type: "EXCLUDE", level: 2,
        totalCount: 5, excludes: ["tomato"]},
      
      // ADDITIONAL LEVEL 3 RIDDLES - Ultimate challenges
      { id: "l3_9", text: "The trinity of the earth: bread, meat, and sacred gift only", type: "COUNT", level: 3,
        counts: { bread: 1, meat: 1, cheese: 1 }},
      { id: "l3_10", text: "Five different souls, each unique in the divine vessel", type: "UNIQUE", level: 3,
        totalCount: 5, uniqueOnly: true},
      { id: "l3_11", text: "Hermes' perfect symmetry: two of grain, two of earth's fire", type: "COUNT", level: 3,
        counts: { bread: 2, pepper: 2 }},
      { id: "l3_12", text: "The feast of four, with no repeating souls", type: "UNIQUE", level: 3,
        totalCount: 4, uniqueOnly: true},
      { id: "l3_13", text: "Exactly five offerings, but the hunter brings nothing", type: "EXCLUDE", level: 3,
        totalCount: 5, excludes: ["meat"]},
      { id: "l3_14", text: "The divine sandwich of Zeus: his creation wrapped in gold", type: "SANDWICH", level: 3,
        bread: true, filling: ["egg"]},
      { id: "l3_15", text: "Three unique souls only, each different from the others", type: "UNIQUE", level: 3,
        totalCount: 3, uniqueOnly: true}
    ];
    
    // Customer database
    const CUSTOMERS = [
      { id: "minotaur", name: "Minotaur", 
        success: ["The labyrinth rests.", "Straight through.", "Your path is clear."],
        failure: ["Lost already?", "Wrong turn taken.", "The maze claims you."], 
        timeout: ["The maze does not wait.", "Time traps the lost.", "Choose swiftly."]},
      { id: "medusa", name: "Medusa",
        success: ["Stone-cold perfect.", "Acceptable gaze.", "Your eyes see truth."],
        failure: ["You froze.", "Turned to failure.", "Gaze upon your mistake."],
        timeout: ["Petrified by seconds?", "Time turns you to stone.", "Hesitation kills."]},
      { id: "hermes", name: "Hermes",
        success: ["Swift and sure.", "Wings approved.", "Speed and precision unite."],
        failure: ["Outpaced again.", "Too slow, mortal.", "Haste without thought."],
        timeout: ["Wings beat you.", "Swift time escapes.", "The messenger departs."]},
      { id: "sphinx", name: "Sphinx",
        success: ["Your mind is awake.", "The riddle yields.", "Wisdom is shown."],
        failure: ["Answer me properly.", "Your mind falters.", "Think harder, mortal."],
        timeout: ["Silence is not an answer.", "Time riddles all.", "The sphinx waits not."]},
      { id: "pegasus", name: "Pegasus",
        success: ["Wings of satisfaction.", "Sky-high approval.", "Divine flight achieved."],
        failure: ["Grounded by error.", "Wings clipped.", "Fall from grace."],
        timeout: ["Time flies away.", "Swift as wind departs.", "The sky cannot wait."]},
      { id: "poseidon", name: "Poseidon",
        success: ["The seas are pleased.", "Tidal perfection.", "Oceanic approval flows."],
        failure: ["The depths are angry.", "Storms brew from failure.", "Poseidon's wrath rises."],
        timeout: ["The tide waits not.", "Waves of time crash over.", "The ocean reclaims all."]},
      { id: "ghost", name: "Restless Spirit",
        success: ["The veil shivers.", "Peace flows.", "Rest is granted."],
        failure: ["Whispers say no.", "Unrest grows.", "The dead are displeased."],
        timeout: ["Time slipped through you.", "Eternity waits not.", "The spirit fades."]}
    ];
    
    // Randomize customer order for each game
    function shuffleCustomers() {
      const shuffled = [...CUSTOMERS];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }
    
    console.log(`‚úÖ Loaded ${RIDDLES.length} riddles and ${CUSTOMERS.length} customers`);
    
    // =============================================================================
    // GAME STATE
    // =============================================================================
    
    // Main game state object
    const game = {
      // Game flow
      state: 'menu',              // 'menu', 'playing', 'paused', 'won'
      score: 0,
      level: 1,
      
      // Player
      player: {
        x: 640,                   // Start at table center
        y: 360,
        carrying: null,           // null or ingredient name string
        currentZone: null,        // Which interaction zone player is in
        speed: CONFIG.PLAYER_SPEED
      },
      
      // Plate & ingredients
      plate: [],                  // Array of ingredient strings, max 5
      
      // Riddle system
      currentRiddle: null,        // Current riddle object
      riddleIndex: 0,             // Track which riddle we're on
      usedRiddles: [],            // Track used riddles to avoid repeats
      
      // Customer system
      currentCustomer: null,      // Current customer object
      customerIndex: 0,           // Rotation index
      customerMessage: '',        // What customer is saying
      messageTimer: 0,            // How long to show message
      shuffledCustomers: [],      // Randomized customer order
      customerPosition: { x: 0, y: 0 }, // Current customer position
      customerState: 'walking_in',    // 'walking_in', 'waiting', 'walking_out'
      customerAnimation: 0,           // Animation frame counter
      
      // Timing
      timer: CONFIG.LEVEL_1_TIME, // Current timer
      timePerRiddle: CONFIG.LEVEL_1_TIME,
      lastTime: 0,                // For delta time
      deliveryDebounce: 0,        // Prevent double delivery
      
      // Feedback
      toastMessage: '',           // Current toast message
      toastTimer: 0,              // How long to show toast
      
      // Debug
      debugMode: false,
      showHitboxes: false,
      frameCount: 0,
      lastFPSTime: 0,
      currentFPS: 60
    };
    
    console.log("‚úÖ Game state initialized:", game);
    
    // =============================================================================
    // INPUT SYSTEM (KEYBOARD ONLY)
    // =============================================================================
    
    const input = {
      keys: {},
      keyPressed: {}, // Track single presses to prevent repeats
      
      init() {
        // Keydown handler
        document.addEventListener('keydown', (e) => {
          const key = e.key.toLowerCase();
          this.keys[key] = true;
          
          // Prevent defaults for game keys
          if (['w','a','s','d','e','q','x','enter','escape'].includes(key)) {
            e.preventDefault();
          }
          
          // Special keys
          if (key === 'escape' && game.state === 'playing') {
            game.state = 'paused';
            console.log("Game paused");
          } else if (key === 'escape' && game.state === 'paused') {
            game.state = 'playing';
            console.log("Game resumed");
          }
          
          // Debug keys
          if (key === '`' || key === '~') {
            game.debugMode = !game.debugMode;
            console.log('Debug mode:', game.debugMode);
          }
          
          if (key === 'f1' && game.debugMode) {
            game.showHitboxes = !game.showHitboxes;
            console.log('Show hitboxes:', game.showHitboxes);
          }
        });
        
        // Keyup handler
        document.addEventListener('keyup', (e) => {
          const key = e.key.toLowerCase();
          this.keys[key] = false;
          this.keyPressed[key] = false;
        });
        
        // Window blur (auto-pause)
        window.addEventListener('blur', () => {
          this.keys = {}; // Clear all keys
          this.keyPressed = {};
          if (game.state === 'playing') {
            game.state = 'paused';
            console.log("Game auto-paused (window blur)");
          }
        });
        
        console.log('‚úÖ Input system initialized');
      },
      
      // Check if key is currently pressed
      isPressed(key) {
        return !!this.keys[key.toLowerCase()];
      },
      
      // Check if key was just pressed (single press)
      wasPressed(key) {
        const k = key.toLowerCase();
        if (this.keys[k] && !this.keyPressed[k]) {
          this.keyPressed[k] = true;
          return true;
        }
        return false;
      },
      
      // Get movement vector (normalized for diagonal)
      getMovementVector() {
        let x = 0, y = 0;
        
        if (this.isPressed('a')) x -= 1;
        if (this.isPressed('d')) x += 1;
        if (this.isPressed('w')) y -= 1;
        if (this.isPressed('s')) y += 1;
        
        // Normalize diagonal movement
        if (x !== 0 && y !== 0) {
          x *= 0.707; // 1/sqrt(2)
          y *= 0.707;
        }
        
        return { x, y };
      }
    };
    
    // =============================================================================
    // UTILITY FUNCTIONS
    // =============================================================================
    
    // Distance helper
    function distance(x1, y1, x2, y2) {
      return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    }
    
    // Random choice helper
    function randomChoice(array) {
      return array[Math.floor(Math.random() * array.length)];
    }
    
    // Toast message system
    function showToast(message) {
      game.toastMessage = message;
      game.toastTimer = 2000; // Show for 2 seconds
      console.log(`Toast: ${message}`);
    }
    
    // =============================================================================
    // RIDDLE VALIDATION SYSTEM (PHASE 2)
    // =============================================================================
    
    // Validate plate against riddle
    function validatePlate(plate, riddle) {
      if (!riddle) return { success: false, reason: "No active riddle" };
      
      // COUNT validation
      if (riddle.type === "COUNT") {
        const plateCounts = {};
        plate.forEach(item => {
          plateCounts[item] = (plateCounts[item] || 0) + 1;
        });
        
        // Check exact matches
        for (let ingredient in riddle.counts) {
          if (plateCounts[ingredient] !== riddle.counts[ingredient]) {
            return { success: false, reason: "Wrong ingredients" };
          }
        }
        
        // Check no extras
        for (let ingredient in plateCounts) {
          if (!riddle.counts[ingredient]) {
            return { success: false, reason: "Extra ingredients" };
          }
        }
        
        return { success: true };
      }
      
      // EXCLUDE validation
      if (riddle.type === "EXCLUDE") {
        const plateCounts = {};
        plate.forEach(item => {
          plateCounts[item] = (plateCounts[item] || 0) + 1;
        });
        
        // Check excluded items
        for (let excluded of riddle.exclude || []) {
          if (plateCounts[excluded] > 0) {
            return { success: false, reason: `Contains ${excluded}!` };
          }
        }
        
        // Check required items
        for (let ingredient in riddle.counts) {
          if (plateCounts[ingredient] !== riddle.counts[ingredient]) {
            return { success: false, reason: "Wrong ingredients" };
          }
        }
        
        return { success: true };
      }
      
      // SANDWICH validation
      if (riddle.type === "SANDWICH") {
        if (plate.length !== riddle.sandwich.length) {
          return { success: false, reason: `Need exactly ${riddle.sandwich.length} items` };
        }
        
        for (let i = 0; i < riddle.sandwich.length; i++) {
          if (plate[i] !== riddle.sandwich[i]) {
            return { success: false, reason: "Wrong sandwich order" };
          }
        }
        
        return { success: true };
      }
      
      // TOTALCOUNT validation (Phase 4 - New type)
      if (riddle.type === "TOTALCOUNT") {
        if (plate.length !== riddle.totalCount) {
          return { success: false, reason: `Need exactly ${riddle.totalCount} items` };
        }
        
        return { success: true };
      }
      
      // UNIQUE validation (Phase 4 - New type)
      if (riddle.type === "UNIQUE") {
        if (plate.length !== riddle.totalCount) {
          return { success: false, reason: `Need exactly ${riddle.totalCount} items` };
        }
        
        const uniqueItems = new Set(plate);
        if (uniqueItems.size !== plate.length) {
          return { success: false, reason: "All items must be different!" };
        }
        
        return { success: true };
      }
      
      return { success: false, reason: "Unknown riddle type" };
    }
    
    // Get next riddle
    function nextRiddle() {
      // Get riddles for current level
      const levelRiddles = RIDDLES.filter(r => r.level === game.level);
      
      // Avoid repeats
      const available = levelRiddles.filter(r => !game.usedRiddles.includes(r.id));
      
      if (available.length === 0) {
        // Reset if we've used all riddles
        game.usedRiddles = [];
        nextRiddle();
        return;
      }
      
      // Pick random riddle
      game.currentRiddle = randomChoice(available);
      game.usedRiddles.push(game.currentRiddle.id);
      
      // Reset timer
      game.timer = game.timePerRiddle;
      
      // Get next customer from shuffled order
      if (game.shuffledCustomers.length === 0) {
        game.shuffledCustomers = shuffleCustomers();
      }
      game.currentCustomer = game.shuffledCustomers[game.customerIndex % game.shuffledCustomers.length];
      game.customerIndex++;
      game.customerMessage = '';
      game.messageTimer = 0;
      
      // Reset customer animation
      game.customerState = 'walking_in';
      game.customerPosition.x = KITCHEN.CUSTOMER_AREA.LEFT;
      game.customerPosition.y = KITCHEN.CUSTOMER_AREA.ENTRANCE_Y;
      game.customerAnimation = 0;
      
      // Clear plate
      game.plate = [];
      
      console.log(`New riddle: ${game.currentRiddle.text} (${game.currentRiddle.type}) - ${game.timer}s`);
    }
    
    // Update level based on score
    function updateLevel() {
      const prevLevel = game.level;
      
      if (game.score >= CONFIG.LEVEL_3_SCORE) {
        game.level = 3;
        game.timePerRiddle = CONFIG.LEVEL_3_TIME;
      } else if (game.score >= CONFIG.LEVEL_2_SCORE) {
        game.level = 2;
        game.timePerRiddle = CONFIG.LEVEL_2_TIME;
      }
      
      if (game.level > prevLevel) {
        showToast(`SPEED UP! Level ${game.level}`);
        console.log(`Level up to ${game.level}! Time per riddle: ${game.timePerRiddle}s`);
        AUDIO.playLevelUp(); // Phase 3 - Audio feedback
      }
    }
    
    // =============================================================================
    // COLLISION & ZONE DETECTION
    // =============================================================================
    
    // Check what zone the player is in
    function updatePlayerZone() {
      const player = game.player;
      const prevZone = player.currentZone;
      player.currentZone = null;
      
      // Check table zone (circular)
      const tableDist = distance(player.x, player.y, 
                                KITCHEN.POSITIONS.TABLE.x, 
                                KITCHEN.POSITIONS.TABLE.y);
      if (tableDist < KITCHEN.ZONES.TABLE_RADIUS) {
        player.currentZone = 'table';
        return;
      }
      
      // Check counter/delivery zone (rectangular)
      const counter = KITCHEN.POSITIONS.COUNTER;
      if (Math.abs(player.x - counter.x) < KITCHEN.ZONES.COUNTER_WIDTH/2 &&
          Math.abs(player.y - counter.y) < KITCHEN.ZONES.COUNTER_HEIGHT/2 + 30) {
        player.currentZone = 'counter';
        return;
      }
      
      // Check trash zone (circular)
      const trashDist = distance(player.x, player.y, 
                                KITCHEN.POSITIONS.TRASH.x, 
                                KITCHEN.POSITIONS.TRASH.y);
      if (trashDist < KITCHEN.ZONES.TRASH_RADIUS) {
        player.currentZone = 'trash';
        return;
      }
      
      // Check ingredient bins (circular)
      for (let [ingredient, pos] of Object.entries(KITCHEN.POSITIONS.BINS)) {
        const dist = distance(player.x, player.y, pos.x, pos.y);
        if (dist < KITCHEN.ZONES.BIN_RADIUS) {
          player.currentZone = `bin_${ingredient.toLowerCase()}`;
          return;
        }
      }
      
      // Log zone changes for debugging
      if (prevZone !== player.currentZone && game.debugMode) {
        console.log(`Zone change: ${prevZone} ‚Üí ${player.currentZone}`);
      }
    }
    
    // =============================================================================
    // CUSTOMER ANIMATION SYSTEM (PHASE 5)
    // =============================================================================
    
    // Update customer walking animation
    function updateCustomerAnimation(deltaTime) {
      if (!game.currentCustomer) return;
      
      const animSpeed = 2; // pixels per frame
      game.customerAnimation += deltaTime;
      
      if (game.customerState === 'walking_in') {
        // Walk from entrance to queue position
        game.customerPosition.x += animSpeed;
        if (game.customerPosition.x >= KITCHEN.CUSTOMER_AREA.QUEUE_X) {
          game.customerPosition.x = KITCHEN.CUSTOMER_AREA.QUEUE_X;
          game.customerState = 'waiting';
        }
      } else if (game.customerState === 'walking_out') {
        // Walk from queue to exit
        game.customerPosition.y += animSpeed;
        if (game.customerPosition.y >= KITCHEN.CUSTOMER_AREA.EXIT_Y) {
          game.customerPosition.y = KITCHEN.CUSTOMER_AREA.EXIT_Y;
          game.customerState = 'gone';
        }
      }
    }
    
    // =============================================================================
    // PLAYER MECHANICS
    // =============================================================================
    
    // Player movement update
    function updatePlayer(deltaTime) {
      if (game.state !== 'playing') return;
      
      const movement = input.getMovementVector();
      const player = game.player;
      
      // Calculate new position
      const newX = player.x + (movement.x * player.speed);
      const newY = player.y + (movement.y * player.speed);
      
      // Apply boundaries
      const halfSize = CONFIG.PLAYER_SIZE / 2;
      player.x = Math.max(KITCHEN.BOUNDS.LEFT + halfSize,
                         Math.min(KITCHEN.BOUNDS.RIGHT - halfSize, newX));
      player.y = Math.max(KITCHEN.BOUNDS.TOP + halfSize,
                         Math.min(KITCHEN.BOUNDS.BOTTOM - halfSize, newY));
      
      // Update current zone
      updatePlayerZone();
    }
    
    // Pickup/place mechanics
    function handleInteraction() {
      const player = game.player;
      const zone = player.currentZone;
      
      if (!zone) {
        showToast("Nothing here to interact with");
        return;
      }
      
      // At ingredient bin
      if (zone.startsWith('bin_')) {
        const ingredient = zone.replace('bin_', '');
        
        if (player.carrying) {
          showToast("Hands full!");
        } else {
          player.carrying = ingredient;
          showToast(`Picked up ${ingredient}`);
          console.log(`Picked up: ${ingredient}`);
          AUDIO.playPickup(); // Phase 3 - Audio feedback
        }
      }
      
      // At table
      else if (zone === 'table') {
        if (player.carrying) {
          if (game.plate.length >= CONFIG.MAX_PLATE_SIZE) {
            showToast("Plate is full!");
          } else {
            game.plate.push(player.carrying);
            showToast(`Placed ${player.carrying}`);
            console.log(`Plate now: ${game.plate.join(', ')}`);
            player.carrying = null;
            AUDIO.playPlace(); // Phase 3 - Audio feedback
          }
        } else {
          showToast("Pick up an ingredient first");
        }
      }
    }
    
    // Undo function (Q key at table)
    function handleUndo() {
      if (game.player.currentZone !== 'table') {
        showToast("Go to table to undo");
        return;
      }
      
      if (game.plate.length === 0) {
        showToast("Nothing to undo");
        return;
      }
      
      const removed = game.plate.pop();
      showToast(`Removed ${removed}`);
      console.log(`Undid ${removed}, plate now: ${game.plate.join(', ')}`);
      AUDIO.playPlace(); // Phase 3 - Audio feedback (same as place, but reversed)
    }
    
    // Trash function (X key at trash)
    function handleTrash() {
      if (game.player.currentZone !== 'trash') {
        showToast("Go to trash bin to discard");
        return;
      }
      
      if (!game.player.carrying) {
        showToast("Nothing to trash");
        return;
      }
      
      const trashed = game.player.carrying;
      game.player.carrying = null;
      showToast(`Trashed ${trashed}`);
      console.log(`Trashed: ${trashed}`);
      AUDIO.playTrash(); // Phase 3 - Audio feedback
    }
    
    // Delivery function (Phase 2 - Real validation)
    function handleDelivery() {
      if (game.player.currentZone !== 'counter') {
        showToast("Go to counter to deliver");
        return;
      }
      
      if (game.deliveryDebounce > 0) return; // Prevent double delivery
      
      if (game.plate.length === 0) {
        showToast("Nothing to serve");
        return;
      }
      
      // Validate the plate
      const result = validatePlate(game.plate, game.currentRiddle);
      
      if (result.success) {
        // Success!
        game.score++;
        game.customerMessage = randomChoice(game.currentCustomer.success);
        game.messageTimer = 2000;
        showToast("Correct! +1 point");
        console.log(`SUCCESS! Score: ${game.score}`);
        AUDIO.playSuccess(); // Phase 3 - Audio feedback
        
        // Check for level up
        updateLevel();
        
        // Check for win
        if (game.score >= CONFIG.WIN_SCORE) {
          game.state = 'won';
          console.log("GAME WON!");
          return;
        }
        
        // Customer walks out, then next riddle
        game.customerState = 'walking_out';
        setTimeout(() => nextRiddle(), 2500); // Give time for walking animation
      } else {
        // Failure
        game.customerMessage = randomChoice(game.currentCustomer.failure);
        game.messageTimer = 2000;
        showToast(`Wrong! ${result.reason}`);
        console.log(`FAILED: ${result.reason}`);
        AUDIO.playFailure(); // Phase 3 - Audio feedback
        
        // Customer walks out after feedback, then next riddle
        game.customerState = 'walking_out';
        setTimeout(() => nextRiddle(), 2500); // Give time for walking animation
      }
      
      // Clear plate and set debounce
      game.plate = [];
      game.deliveryDebounce = 300;
    }
    
    // =============================================================================
    // RENDERING SYSTEM
    // =============================================================================
    
    // Render kitchen layout
    function renderKitchen() {
      // Floor
      ctx.fillStyle = CONFIG.COLORS.FLOOR;
      ctx.fillRect(KITCHEN.BOUNDS.LEFT, KITCHEN.BOUNDS.TOP,
                   KITCHEN.BOUNDS.RIGHT - KITCHEN.BOUNDS.LEFT,
                   KITCHEN.BOUNDS.BOTTOM - KITCHEN.BOUNDS.TOP);
      
      // Walls
      ctx.fillStyle = CONFIG.COLORS.WALL;
      ctx.fillRect(0, 0, canvas.width, KITCHEN.BOUNDS.TOP); // Top
      ctx.fillRect(0, KITCHEN.BOUNDS.BOTTOM, canvas.width, canvas.height); // Bottom
      ctx.fillRect(0, 0, KITCHEN.BOUNDS.LEFT, canvas.height); // Left
      ctx.fillRect(KITCHEN.BOUNDS.RIGHT, 0, canvas.width, canvas.height); // Right
      
      // Ingredient crates (Mount Olympus dungeon style with crate.png)
      const crateSize = 90; // Size for Greek mythological crates
      for (let [ingredient, pos] of Object.entries(KITCHEN.POSITIONS.BINS)) {
        
        // Draw wooden crate background using crate.png
        const crateImg = ASSETS.ui.crate;
        if (crateImg && ASSETS.loaded) {
          // Draw the crate as background
          ctx.drawImage(
            crateImg,
            pos.x - crateSize/2,
            pos.y - crateSize/2,
            crateSize,
            crateSize
          );
        } else {
          // Fallback wooden crate appearance
          const crateGradient = ctx.createLinearGradient(pos.x - crateSize/2, pos.y - crateSize/2, 
                                                        pos.x + crateSize/2, pos.y + crateSize/2);
          crateGradient.addColorStop(0, '#D2691E'); // Chocolate
          crateGradient.addColorStop(0.5, '#A0522D'); // Sienna
          crateGradient.addColorStop(1, '#8B4513'); // Saddle brown
          ctx.fillStyle = crateGradient;
          ctx.fillRect(pos.x - crateSize/2, pos.y - crateSize/2, crateSize, crateSize);
          
          // Wood planks pattern
          ctx.strokeStyle = '#654321';
          ctx.lineWidth = 2;
          for (let i = 0; i < 3; i++) {
            const plankY = pos.y - crateSize/2 + (i * crateSize/3);
            ctx.beginPath();
            ctx.moveTo(pos.x - crateSize/2, plankY);
            ctx.lineTo(pos.x + crateSize/2, plankY);
            ctx.stroke();
          }
        }
        
        // Torchlight glow around crate
        const torchFlicker = Math.sin(Date.now() * 0.005 + pos.x * 0.01) * 0.1 + 0.9;
        ctx.shadowColor = `rgba(255, 140, 0, ${0.3 * torchFlicker})`;
        ctx.shadowBlur = 10;
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 3;
        ctx.strokeRect(pos.x - crateSize/2, pos.y - crateSize/2, crateSize, crateSize);
        ctx.shadowBlur = 0;
        
        // Just show empty crates - no ingredient images on top
        // Crates are labeled below, that's enough visual indication
        
        // Ancient-style label with parchment appearance
        const labelWidth = 85;
        const labelHeight = 24;
        const labelY = pos.y + 32;
        
        // Parchment background
        ctx.fillStyle = '#F5DEB3'; // Wheat/parchment
        ctx.fillRect(pos.x - labelWidth/2, labelY, labelWidth, labelHeight);
        
        // Parchment border and aging
        ctx.strokeStyle = '#D2691E';
        ctx.lineWidth = 2;
        ctx.strokeRect(pos.x - labelWidth/2, labelY, labelWidth, labelHeight);
        
        // Burn marks for aged effect
        ctx.fillStyle = 'rgba(139, 69, 19, 0.2)';
        ctx.fillRect(pos.x - labelWidth/2 + 2, labelY + 2, labelWidth - 4, labelHeight - 4);
        
        // Ancient Greek-style text
        ctx.fillStyle = '#8B4513';
        ctx.font = 'bold 12px Cinzel, serif';
        ctx.textAlign = 'center';
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 0.5;
        ctx.strokeText(ingredient.toUpperCase(), pos.x, labelY + 16);
        ctx.fillText(ingredient.toUpperCase(), pos.x, labelY + 16);
        
        // Golden interaction highlight with divine glow
        if (game.player.currentZone === `bin_${ingredient.toLowerCase()}`) {
          ctx.strokeStyle = '#FFD700';
          ctx.lineWidth = 4;
          ctx.setLineDash([5, 5]);
          ctx.shadowColor = '#FFD700';
          ctx.shadowBlur = 20;
          ctx.strokeRect(pos.x - crateSize/2 - 8, pos.y - crateSize/2 - 8, 
                        crateSize + 16, crateSize + 16);
          ctx.setLineDash([]);
          ctx.shadowBlur = 0;
          
          // Divine particles effect
          for (let i = 0; i < 5; i++) {
            const angle = (Date.now() * 0.01 + i) % (Math.PI * 2);
            const radius = 50 + Math.sin(Date.now() * 0.01 + i) * 10;
            const sparkleX = pos.x + Math.cos(angle) * radius;
            const sparkleY = pos.y + Math.sin(angle) * radius;
            
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(sparkleX - 1, sparkleY - 1, 2, 2);
          }
        }
      }
      
      // Ancient Work Table (simplified - no plate)
      const table = KITCHEN.POSITIONS.TABLE;
      
      // Table surface - simple rectangular stone table
      const tableGrad = ctx.createLinearGradient(table.x - 120, table.y - 80, table.x - 120, table.y + 80);
      tableGrad.addColorStop(0, '#A0522D'); // Sienna
      tableGrad.addColorStop(0.5, '#8B4513'); // Saddle brown
      tableGrad.addColorStop(1, '#654321'); // Dark brown
      ctx.fillStyle = tableGrad;
      ctx.fillRect(table.x - 120, table.y - 80, 240, 160);
      
      // Stone table border
      ctx.strokeStyle = '#654321';
      ctx.lineWidth = 4;
      ctx.strokeRect(table.x - 120, table.y - 80, 240, 160);
      
      // Inner carved border for stone effect
      ctx.strokeStyle = '#D2691E';
      ctx.lineWidth = 2;
      ctx.strokeRect(table.x - 116, table.y - 76, 232, 152);
      
      // Simple stone texture lines
      ctx.strokeStyle = '#965A32';
      ctx.lineWidth = 1;
      for (let i = 0; i < 3; i++) {
        const lineY = table.y - 40 + (i * 40);
        ctx.beginPath();
        ctx.moveTo(table.x - 100, lineY);
        ctx.lineTo(table.x + 100, lineY);
        ctx.stroke();
      }
      
      // Ingredient slots on plate (Phase 3 - Show PNG ingredients)
      for (let i = 0; i < 5; i++) {
        const angle = (i * Math.PI * 2) / 5 - Math.PI/2; // Start at top, go clockwise
        const radius = 35; // Distance from center
        const slotX = table.x + Math.cos(angle) * radius;
        const slotY = table.y + Math.sin(angle) * radius;
        
        // Draw ingredient on plate if present
        if (game.plate[i]) {
          const ingredientImg = ASSETS.ingredients[game.plate[i]];
          if (ingredientImg && ASSETS.loaded) {
            const imgSize = 36; // Increased size for better visibility
            ctx.drawImage(
              ingredientImg,
              slotX - imgSize/2,
              slotY - imgSize/2,
              imgSize,
              imgSize
            );
          } else {
            // Fallback to colored circle
            ctx.fillStyle = CONFIG.COLORS[game.plate[i].toUpperCase()];
            ctx.beginPath();
            ctx.arc(slotX, slotY, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.stroke();
          }
        } else {
          // Empty slot indicator
          ctx.strokeStyle = '#CCC';
          ctx.lineWidth = 1;
          ctx.setLineDash([3, 3]);
          ctx.beginPath();
          ctx.arc(slotX, slotY, 12, 0, Math.PI * 2);
          ctx.stroke();
          ctx.setLineDash([]);
        }
      }
      
      // Highlight table if player is near
      if (game.player.currentZone === 'table') {
        ctx.strokeStyle = '#FFD700';
        ctx.lineWidth = 3;
        ctx.strokeRect(table.x - 105, table.y - 65, 210, 130);
      }
      
      // Ancient Delivery Altar (enhanced counter design)
      const counter = KITCHEN.POSITIONS.COUNTER;
      const altarWidth = 300;
      const altarHeight = 50;
      
      // Stone altar base with gradient
      const altarGrad = ctx.createLinearGradient(counter.x - altarWidth/2, counter.y - altarHeight/2,
                                                counter.x - altarWidth/2, counter.y + altarHeight/2);
      altarGrad.addColorStop(0, '#A0522D'); // Sienna
      altarGrad.addColorStop(0.5, '#8B4513'); // Saddle brown
      altarGrad.addColorStop(1, '#654321'); // Dark brown
      ctx.fillStyle = altarGrad;
      ctx.fillRect(counter.x - altarWidth/2, counter.y - altarHeight/2, altarWidth, altarHeight);
      
      // Ancient carved border
      ctx.strokeStyle = '#654321';
      ctx.lineWidth = 4;
      ctx.strokeRect(counter.x - altarWidth/2, counter.y - altarHeight/2, altarWidth, altarHeight);
      
      // Inner carved design
      ctx.strokeStyle = '#D2691E'; // Chocolate
      ctx.lineWidth = 2;
      ctx.strokeRect(counter.x - altarWidth/2 + 4, counter.y - altarHeight/2 + 4, 
                    altarWidth - 8, altarHeight - 8);
      
      // Ancient symbols/decorations on altar
      ctx.fillStyle = '#DAA520'; // Dark goldenrod
      ctx.font = 'bold 16px Cinzel, serif';
      ctx.textAlign = 'center';
      ctx.fillText('‚ö±', counter.x - 80, counter.y + 6);  // Left urn
      ctx.fillText('üèõ', counter.x, counter.y + 6);        // Center temple
      ctx.fillText('‚ö±', counter.x + 80, counter.y + 6);   // Right urn
      
      // Divine glow when player is near
      if (game.player.currentZone === 'counter') {
        // Golden divine aura
        ctx.shadowColor = '#FFD700';
        ctx.shadowBlur = 20;
        ctx.strokeStyle = '#FFD700';
        ctx.lineWidth = 4;
        ctx.setLineDash([8, 4]);
        ctx.strokeRect(counter.x - altarWidth/2 - 8, counter.y - altarHeight/2 - 8, 
                      altarWidth + 16, altarHeight + 16);
        ctx.setLineDash([]);
        ctx.shadowBlur = 0;
        
        // Divine particles around altar
        for (let i = 0; i < 6; i++) {
          const angle = (Date.now() * 0.003 + i) % (Math.PI * 2);
          const radius = 180 + Math.sin(Date.now() * 0.005 + i) * 15;
          const particleX = counter.x + Math.cos(angle) * radius;
          const particleY = counter.y + Math.sin(angle) * radius;
          
          ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
          ctx.beginPath();
          ctx.arc(particleX, particleY, 3, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Trash bin
      const trash = KITCHEN.POSITIONS.TRASH;
      const trashSize = 50;
      
      // Trash bin body (dark gray)
      ctx.fillStyle = '#404040';
      ctx.fillRect(trash.x - trashSize/2, trash.y - trashSize/2, trashSize, trashSize);
      
      // Trash bin lid (lighter gray)
      ctx.fillStyle = '#606060';
      ctx.fillRect(trash.x - trashSize/2 - 5, trash.y - trashSize/2 - 8, trashSize + 10, 15);
      
      // Trash bin border
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.strokeRect(trash.x - trashSize/2, trash.y - trashSize/2, trashSize, trashSize);
      ctx.strokeRect(trash.x - trashSize/2 - 5, trash.y - trashSize/2 - 8, trashSize + 10, 15);
      
      // Trash icon/lines
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(trash.x - 15, trash.y - 10);
      ctx.lineTo(trash.x - 15, trash.y + 15);
      ctx.moveTo(trash.x, trash.y - 10);
      ctx.lineTo(trash.x, trash.y + 15);
      ctx.moveTo(trash.x + 15, trash.y - 10);
      ctx.lineTo(trash.x + 15, trash.y + 15);
      ctx.stroke();
      
      // Highlight if player is near
      if (game.player.currentZone === 'trash') {
        ctx.strokeStyle = '#FFD700';
        ctx.lineWidth = 3;
        ctx.strokeRect(trash.x - trashSize/2 - 5, trash.y - trashSize/2 - 5, 
                      trashSize + 10, trashSize + 10);
      }
      
      // Labels
      ctx.fillStyle = '#FFF';
      ctx.font = 'bold 14px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('TABLE', table.x, table.y - 75);
      ctx.fillText('DIVINE ALTAR', counter.x, counter.y - 35);
      ctx.fillText('TRASH', trash.x, trash.y + 40);
    }
    
    // Render player (Enhanced with character sprite)
    function renderPlayer() {
      const player = game.player;
      
      // Draw player character sprite if available
      const characterImg = ASSETS.player?.character;
      if (characterImg && ASSETS.loaded) {
        const spriteSize = 64; // Increased size for better visibility
        
        // Draw character sprite
        ctx.drawImage(
          characterImg,
          player.x - spriteSize/2,
          player.y - spriteSize/2,
          spriteSize,
          spriteSize
        );
        
        // Add subtle glow around player for visibility
        ctx.shadowColor = 'rgba(255, 255, 255, 0.3)';
        ctx.shadowBlur = 8;
        ctx.drawImage(
          characterImg,
          player.x - spriteSize/2,
          player.y - spriteSize/2,
          spriteSize,
          spriteSize
        );
        ctx.shadowBlur = 0;
      } else {
        // Fallback to classic square design
        ctx.fillStyle = CONFIG.COLORS.PLAYER;
        ctx.fillRect(player.x - CONFIG.PLAYER_SIZE/2,
                     player.y - CONFIG.PLAYER_SIZE/2,
                     CONFIG.PLAYER_SIZE, CONFIG.PLAYER_SIZE);
        
        // Player border
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.strokeRect(player.x - CONFIG.PLAYER_SIZE/2,
                       player.y - CONFIG.PLAYER_SIZE/2,
                       CONFIG.PLAYER_SIZE, CONFIG.PLAYER_SIZE);
      }
      
      // Carried item (Phase 5 - Enhanced appearance)
      if (player.carrying) {
        const carriedImg = ASSETS.ingredients[player.carrying];
        if (carriedImg && ASSETS.loaded) {
          // Draw ingredient PNG above player with better size
          const imgSize = 56; // Increased size for better visibility
          
          // Add background circle for contrast
          ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
          ctx.beginPath();
          ctx.arc(player.x, player.y - CONFIG.PLAYER_SIZE/2 - imgSize/2 - 8, imgSize/2 + 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#FFD700';
          ctx.lineWidth = 2;
          ctx.stroke();
          
          // Draw the ingredient image
          ctx.drawImage(
            carriedImg,
            player.x - imgSize/2,
            player.y - CONFIG.PLAYER_SIZE/2 - imgSize - 8,
            imgSize,
            imgSize
          );
          
          // Add golden glow effect
          ctx.shadowColor = '#FFD700';
          ctx.shadowBlur = 8;
          ctx.drawImage(
            carriedImg,
            player.x - imgSize/2,
            player.y - CONFIG.PLAYER_SIZE/2 - imgSize - 8,
            imgSize,
            imgSize
          );
          ctx.shadowBlur = 0;
        } else {
          // Enhanced fallback display
          ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
          ctx.fillRect(player.x - 25, player.y - CONFIG.PLAYER_SIZE/2 - 30, 50, 24);
          ctx.strokeStyle = '#FFD700';
          ctx.lineWidth = 2;
          ctx.strokeRect(player.x - 25, player.y - CONFIG.PLAYER_SIZE/2 - 30, 50, 24);
          ctx.fillStyle = '#000';
          ctx.font = 'bold 12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(player.carrying.toUpperCase(), player.x, player.y - CONFIG.PLAYER_SIZE/2 - 12);
        }
      }
    }
    
    // Render customers (Phase 5 - Walking animation in customer area)
    function renderCustomers() {
      if (!game.currentCustomer || game.customerState === 'gone') return;
      
      // Render customer area background
      ctx.fillStyle = 'rgba(139, 69, 19, 0.3)'; // Brown customer area
      ctx.fillRect(KITCHEN.CUSTOMER_AREA.LEFT, KITCHEN.CUSTOMER_AREA.TOP, 
                   KITCHEN.CUSTOMER_AREA.RIGHT - KITCHEN.CUSTOMER_AREA.LEFT, 
                   KITCHEN.CUSTOMER_AREA.BOTTOM - KITCHEN.CUSTOMER_AREA.TOP);
      
      // Customer area border
      ctx.strokeStyle = '#8B4513';
      ctx.lineWidth = 2;
      ctx.strokeRect(KITCHEN.CUSTOMER_AREA.LEFT, KITCHEN.CUSTOMER_AREA.TOP, 
                     KITCHEN.CUSTOMER_AREA.RIGHT - KITCHEN.CUSTOMER_AREA.LEFT, 
                     KITCHEN.CUSTOMER_AREA.BOTTOM - KITCHEN.CUSTOMER_AREA.TOP);
      
      // Queue line indicator
      ctx.strokeStyle = '#654321';
      ctx.lineWidth = 3;
      ctx.setLineDash([10, 10]);
      ctx.beginPath();
      ctx.moveTo(KITCHEN.CUSTOMER_AREA.QUEUE_X, KITCHEN.CUSTOMER_AREA.TOP + 20);
      ctx.lineTo(KITCHEN.CUSTOMER_AREA.QUEUE_X, KITCHEN.CUSTOMER_AREA.BOTTOM - 20);
      ctx.stroke();
      ctx.setLineDash([]);
      
      const customerImg = ASSETS.customers[game.currentCustomer.id];
      const spriteWidth = 96;   // Universal width for all customer sprites (increased resolution)
      const spriteHeight = 128; // Universal height for all customer sprites (increased resolution)
      
      if (customerImg && ASSETS.loaded) {
        // Draw customer sprite at animated position with vertical proportions
        ctx.drawImage(
          customerImg,
          game.customerPosition.x - spriteWidth/2,
          game.customerPosition.y - spriteHeight/2,
          spriteWidth,
          spriteHeight
        );
        
        // Add divine glow effect if waiting
        if (game.customerState === 'waiting') {
          ctx.shadowColor = 'rgba(218, 165, 32, 0.7)'; // Dark goldenrod glow
          ctx.shadowBlur = 15;
          ctx.drawImage(
            customerImg,
            game.customerPosition.x - spriteWidth/2,
            game.customerPosition.y - spriteHeight/2,
            spriteWidth,
            spriteHeight
          );
          ctx.shadowBlur = 0;
          
          // Add mystical particles around waiting customer
          for (let i = 0; i < 3; i++) {
            const angle = (Date.now() * 0.005 + i * 2) % (Math.PI * 2);
            const radius = 60 + Math.sin(Date.now() * 0.01 + i) * 10;
            const particleX = game.customerPosition.x + Math.cos(angle) * radius;
            const particleY = game.customerPosition.y + Math.sin(angle) * radius;
            
            ctx.fillStyle = 'rgba(218, 165, 32, 0.8)';
            ctx.beginPath();
            ctx.arc(particleX, particleY, 2, 0, Math.PI * 2);
            ctx.fill();
          }
        }
        
        // Ancient name plaque (only when waiting)
        if (game.customerState === 'waiting') {
          const plaqueWidth = 90;
          const plaqueHeight = 24;
          const plaqueY = game.customerPosition.y + 55;
          
          // Stone plaque background
          ctx.fillStyle = 'rgba(139, 69, 19, 0.9)'; // Dark brown stone
          ctx.fillRect(game.customerPosition.x - plaqueWidth/2, plaqueY, plaqueWidth, plaqueHeight);
          
          // Carved border effect
          ctx.strokeStyle = '#654321';
          ctx.lineWidth = 2;
          ctx.strokeRect(game.customerPosition.x - plaqueWidth/2, plaqueY, plaqueWidth, plaqueHeight);
          
          // Inner highlight
          ctx.strokeStyle = '#A0522D';
          ctx.lineWidth = 1;
          ctx.strokeRect(game.customerPosition.x - plaqueWidth/2 + 2, plaqueY + 2, 
                        plaqueWidth - 4, plaqueHeight - 4);
          
          // Engraved text effect
          ctx.fillStyle = '#DAA520'; // Dark goldenrod
          ctx.font = 'bold 12px Cinzel, serif';
          ctx.textAlign = 'center';
          ctx.strokeStyle = '#654321';
          ctx.lineWidth = 0.5;
          ctx.strokeText(game.currentCustomer.name, game.customerPosition.x, plaqueY + 16);
          ctx.fillText(game.currentCustomer.name, game.customerPosition.x, plaqueY + 16);
        }
        
        // Speech bubble (only when waiting and has message)
        if (game.customerState === 'waiting' && game.customerMessage && game.messageTimer > 0) {
          renderSpeechBubble(
            game.customerPosition.x,
            game.customerPosition.y - 60,
            game.customerMessage
          );
        }
      } else {
        // Fallback mythological figure (vertical oval)
        ctx.fillStyle = '#8A2BE2'; // Purple for mythical beings
        ctx.beginPath();
        ctx.ellipse(game.customerPosition.x, game.customerPosition.y, 30, 45, 0, 0, Math.PI * 2); // Vertical oval
        ctx.fill();
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 3;
        ctx.stroke();
        
        // Ancient crown or divine symbol
        ctx.fillStyle = '#DAA520';
        ctx.beginPath();
        ctx.ellipse(game.customerPosition.x, game.customerPosition.y - 35, 20, 10, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Customer name with Greek styling
        ctx.fillStyle = '#F5DEB3';
        ctx.font = 'bold 12px Cinzel, serif';
        ctx.textAlign = 'center';
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 1;
        ctx.strokeText(game.currentCustomer.name, game.customerPosition.x, game.customerPosition.y + 55);
        ctx.fillText(game.currentCustomer.name, game.customerPosition.x, game.customerPosition.y + 55);
      }
    }
    
    // Ancient speech scroll helper
    function renderSpeechBubble(x, y, text) {
      const scrollWidth = Math.max(220, text.length * 9);
      const scrollHeight = 45;
      
      // Parchment scroll background
      ctx.fillStyle = 'rgba(245, 222, 179, 0.95)'; // Wheat/parchment with transparency
      ctx.strokeStyle = '#D2691E'; // Chocolate border
      ctx.lineWidth = 3;
      
      // Scroll shape with rounded ends
      ctx.beginPath();
      if (ctx.roundRect) {
        ctx.roundRect(x - scrollWidth/2, y - scrollHeight, scrollWidth, scrollHeight, 15);
      } else {
        // Fallback rectangle
        ctx.rect(x - scrollWidth/2, y - scrollHeight, scrollWidth, scrollHeight);
      }
      ctx.fill();
      ctx.stroke();
      
      // Scroll aging/burn marks
      ctx.fillStyle = 'rgba(139, 69, 19, 0.1)';
      ctx.fillRect(x - scrollWidth/2 + 5, y - scrollHeight + 5, scrollWidth - 10, scrollHeight - 10);
      
      // Inner scroll border
      ctx.strokeStyle = '#CD853F'; // Peru color
      ctx.lineWidth = 1;
      ctx.strokeRect(x - scrollWidth/2 + 4, y - scrollHeight + 4, scrollWidth - 8, scrollHeight - 8);
      
      // Scroll pointer (torn parchment effect)
      ctx.fillStyle = 'rgba(245, 222, 179, 0.95)';
      ctx.strokeStyle = '#D2691E';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x - 12, y);
      ctx.lineTo(x, y + 12);
      ctx.lineTo(x + 12, y);
      ctx.lineTo(x + 8, y - 3);
      ctx.lineTo(x - 8, y - 3);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Ancient script text
      ctx.fillStyle = '#8B4513'; // Saddle brown ink
      ctx.font = 'italic 14px Crimson Text, serif';
      ctx.textAlign = 'center';
      ctx.strokeStyle = '#654321';
      ctx.lineWidth = 0.3;
      ctx.strokeText(`"${text}"`, x, y - scrollHeight/2 + 8);
      ctx.fillText(`"${text}"`, x, y - scrollHeight/2 + 8);
    }
    
    // Render UI
    function renderUI() {
      // Transparent header with stone dungeon styling
      const headerGrad = ctx.createLinearGradient(0, 0, canvas.width, 120);
      headerGrad.addColorStop(0, 'rgba(74, 55, 40, 0.8)'); // Stone brown with transparency
      headerGrad.addColorStop(0.5, 'rgba(44, 24, 16, 0.9)'); // Dark brown  
      headerGrad.addColorStop(1, 'rgba(26, 13, 8, 0.95)'); // Very dark brown
      ctx.fillStyle = headerGrad;
      ctx.fillRect(0, 0, canvas.width, 120);
      
      // Ancient stone border with carved appearance
      ctx.strokeStyle = '#8B4513';
      ctx.lineWidth = 4;
      ctx.strokeRect(2, 2, canvas.width - 4, 116);
      
      // Inner carved border
      ctx.strokeStyle = '#A0522D';
      ctx.lineWidth = 2;
      ctx.strokeRect(6, 6, canvas.width - 12, 108);
      
      // Ancient score display (top-right)
      ctx.fillStyle = '#DAA520'; // Dark goldenrod
      ctx.font = 'bold 22px Cinzel, serif';
      ctx.textAlign = 'right';
      ctx.strokeStyle = '#654321';
      ctx.lineWidth = 2;
      ctx.strokeText(`Souls Served: ${game.score}/${CONFIG.WIN_SCORE}`, canvas.width - 20, 35);
      ctx.fillText(`Souls Served: ${game.score}/${CONFIG.WIN_SCORE}`, canvas.width - 20, 35);
      ctx.strokeText(`Trial Level: ${game.level}`, canvas.width - 20, 60);
      ctx.fillText(`Trial Level: ${game.level}`, canvas.width - 20, 60);
      
      // Enhanced timer with ancient hourglass styling
      if (game.currentRiddle) {
        ctx.textAlign = 'center';
        
        // Timer background - ancient hourglass shape
        const timerX = canvas.width/2;
        const timerY = 45;
        const hourglassWidth = 120;
        const hourglassHeight = 30;
        
        // Hourglass background
        ctx.fillStyle = 'rgba(139, 69, 19, 0.8)';
        ctx.fillRect(timerX - hourglassWidth/2, timerY - hourglassHeight/2, hourglassWidth, hourglassHeight);
        
        // Sand progress bar
        const timePercent = Math.max(0, game.timer / game.timePerRiddle);
        let sandColor;
        if (game.timer <= 5) {
          sandColor = '#DC143C'; // Crimson - danger
        } else if (game.timer <= 10) {
          sandColor = '#FF6347'; // Tomato - warning
        } else {
          sandColor = '#DAA520'; // Dark goldenrod - safe
        }
        
        // Animated sand
        const flickerSand = Math.sin(Date.now() * 0.01) * 0.1 + 0.9;
        ctx.fillStyle = sandColor;
        ctx.globalAlpha = flickerSand;
        ctx.fillRect(timerX - hourglassWidth/2 + 2, timerY - hourglassHeight/2 + 2, 
                    (hourglassWidth - 4) * timePercent, hourglassHeight - 4);
        ctx.globalAlpha = 1;
        
        // Hourglass border
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 3;
        ctx.strokeRect(timerX - hourglassWidth/2, timerY - hourglassHeight/2, hourglassWidth, hourglassHeight);
        
        // Timer text with ancient styling
        ctx.fillStyle = '#F5DEB3'; // Wheat
        ctx.font = 'bold 18px Cinzel, serif';
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 1;
        ctx.strokeText(`${Math.ceil(game.timer)}s`, timerX, timerY + 6);
        ctx.fillText(`${Math.ceil(game.timer)}s`, timerX, timerY + 6);
        
        // Urgent pulsing effect for low time
        if (game.timer <= 5) {
          const pulse = Math.sin(Date.now() * 0.02) * 0.3 + 0.7;
          ctx.shadowColor = '#DC143C';
          ctx.shadowBlur = 15 * pulse;
          ctx.strokeRect(timerX - hourglassWidth/2 - 5, timerY - hourglassHeight/2 - 5, 
                        hourglassWidth + 10, hourglassHeight + 10);
          ctx.shadowBlur = 0;
        }
      }
      
      // Enhanced riddle display with parchment styling
      if (game.currentRiddle) {
        const riddleY = 85;
        const riddleWidth = Math.min(800, game.currentRiddle.text.length * 12);
        
        // Parchment background for riddle
        ctx.fillStyle = 'rgba(245, 222, 179, 0.95)'; // Wheat with transparency
        ctx.fillRect(canvas.width/2 - riddleWidth/2, riddleY - 15, riddleWidth, 25);
        
        // Parchment border
        ctx.strokeStyle = '#D2691E';
        ctx.lineWidth = 2;
        ctx.strokeRect(canvas.width/2 - riddleWidth/2, riddleY - 15, riddleWidth, 25);
        
        // Riddle text with ancient styling
        ctx.fillStyle = '#8B4513'; // Saddle brown
        ctx.font = 'italic 18px Crimson Text, serif';
        ctx.textAlign = 'center';
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 0.5;
        ctx.strokeText(`"${game.currentRiddle.text}"`, canvas.width/2, riddleY);
        ctx.fillText(`"${game.currentRiddle.text}"`, canvas.width/2, riddleY);
      }
      
      // Customer and message - Phase 2
      if (game.currentCustomer) {
        ctx.fillStyle = '#FFD700';
        ctx.font = '16px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(game.currentCustomer.name, 20, 35);
        
        if (game.customerMessage && game.messageTimer > 0) {
          ctx.fillStyle = 'white';
          ctx.font = '14px Arial';
          ctx.fillText(`"${game.customerMessage}"`, 20, 55);
        }
      }
      
      // Debug zone info (if debug mode)
      if (game.debugMode) {
        ctx.fillStyle = '#0F0';
        ctx.font = '12px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`Zone: ${game.player.currentZone || 'none'}`, 20, 85);
        if (game.player.carrying) {
          ctx.fillText(`Carrying: ${game.player.carrying}`, 20, 105);
        }
      }
      
      // Plate contents (below table)
      if (game.plate.length > 0) {
        ctx.fillStyle = 'white';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`Plate: ${game.plate.join(', ')}`, 
                     KITCHEN.POSITIONS.TABLE.x, 
                     KITCHEN.POSITIONS.TABLE.y + 100);
      }
      
      // Toast message (center)
      if (game.toastMessage && game.toastTimer > 0) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        const width = ctx.measureText(game.toastMessage).width + 40;
        ctx.fillRect(canvas.width/2 - width/2, canvas.height/2 - 30, width, 60);
        
        ctx.fillStyle = 'white';
        ctx.font = '18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(game.toastMessage, canvas.width/2, canvas.height/2);
      }
      
      // Controls (bottom)
      ctx.fillStyle = '#AAA';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('WASD: Move | E: Pickup/Place | Q: Undo | X: Trash | Enter: Deliver | ~: Debug',
                   canvas.width/2, canvas.height - 10);
      
      // FPS counter (debug)
      if (game.debugMode) {
        ctx.fillStyle = '#0F0';
        ctx.font = '14px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`FPS: ${game.currentFPS}`, 20, canvas.height - 40);
      }
    }
    
    // Menu screen
    function renderMenu() {
      // Dark stone dungeon background with torchlight
      const bgGrad = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, 
                                              canvas.width/2, canvas.height/2, canvas.width);
      bgGrad.addColorStop(0, '#4A3728'); // Stone brown
      bgGrad.addColorStop(0.7, '#2C1810'); // Dark brown
      bgGrad.addColorStop(1, '#0A0A0A'); // Black void
      ctx.fillStyle = bgGrad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Add stone texture overlay
      ctx.fillStyle = 'rgba(139, 69, 19, 0.1)';
      for (let i = 0; i < 50; i++) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        ctx.fillRect(x, y, 2, 2);
      }
      
      // Torchlight flickering effect
      const flicker = Math.sin(Date.now() * 0.01) * 0.1 + 0.9;
      const torchGrad = ctx.createRadialGradient(canvas.width/2, 50, 0, 
                                                 canvas.width/2, 50, 400);
      torchGrad.addColorStop(0, `rgba(255, 140, 0, ${0.3 * flicker})`);
      torchGrad.addColorStop(1, 'rgba(255, 140, 0, 0)');
      ctx.fillStyle = torchGrad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Main title with ancient Greek styling
      ctx.fillStyle = '#DAA520'; // Dark goldenrod
      ctx.font = 'bold 52px Cinzel, serif';
      ctx.textAlign = 'center';
      ctx.strokeStyle = '#8B4513';
      ctx.lineWidth = 3;
      ctx.strokeText('ORDER OF THE GODS', canvas.width/2, 140);
      ctx.fillText('ORDER OF THE GODS', canvas.width/2, 140);
      
      // Subtitle - Dungeon location
      ctx.fillStyle = '#CD853F'; // Peru color
      ctx.font = 'italic 24px Cinzel, serif';
      ctx.strokeStyle = '#654321';
      ctx.lineWidth = 2;
      ctx.strokeText('Dungeon of Mount Olympus', canvas.width/2, 180);
      ctx.fillText('Dungeon of Mount Olympus', canvas.width/2, 180);
      
      // Prisoner backstory - formatted nicely
      const storyLines = [
        "You are no master chef. You are a prisoner.",
        "",
        "An iron collar bites your neck, its chain dragging you into the Feast Hall",
        "of Eternity‚Äîa torchlit kitchen suspended between Olympus and the mortal world.",
        "",
        "Each night, gods, monsters, and restless spirits gather not to feast,",
        "but to watch you struggle with their riddles.",
        "",
        "Guess wrong, and you are mocked. Serve slow, and you are punished.",
        "The collar loosens with each dish served well... but never falls away.",
        "",
        "You are their servant. Their spectacle. Their captive."
      ];
      
      ctx.fillStyle = '#F5DEB3'; // Wheat color for readable text
      ctx.font = '16px Crimson Text, serif';
      ctx.textAlign = 'center';
      
      let yPos = 230;
      storyLines.forEach((line, index) => {
        if (line === "") {
          yPos += 10; // Smaller spacing for empty lines
        } else {
          // Add subtle shadow for readability
          ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
          ctx.fillText(line, canvas.width/2 + 1, yPos + 1);
          ctx.fillStyle = '#F5DEB3';
          ctx.fillText(line, canvas.width/2, yPos);
          yPos += 20;
        }
      });
      
      // Start prompt with ancient styling
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 28px Cinzel, serif';
      ctx.strokeStyle = '#B8860B';
      ctx.lineWidth = 2;
      ctx.strokeText('Press ENTER to Begin Your Trial', canvas.width/2, yPos + 40);
      ctx.fillText('Press ENTER to Begin Your Trial', canvas.width/2, yPos + 40);
      
      // Controls hint
      ctx.fillStyle = '#CD853F';
      ctx.font = '14px Crimson Text, serif';
      ctx.fillText('WASD: Move | E: Interact | Q: Undo | X: Trash | Enter: Deliver', canvas.width/2, yPos + 80);
      
      // Check for enter key to start
      if (input.wasPressed('enter')) {
        startGame();
      }
    }
    
    // Win screen
    function renderWinScreen() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 64px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('PHASE 1 COMPLETE!', canvas.width/2, 250);
      
      ctx.fillStyle = 'white';
      ctx.font = '32px Arial';
      ctx.fillText(`Final Score: ${game.score} points`, canvas.width/2, 350);
      
      ctx.font = '24px Arial';
      ctx.fillText('Core mechanics working!', canvas.width/2, 420);
      
      ctx.font = '32px Arial';
      ctx.fillText('Press ENTER to Restart', canvas.width/2, 520);
      
      // Check for restart
      if (input.wasPressed('enter')) {
        location.reload(); // Simple restart
      }
    }
    
    // Pause overlay
    function renderPauseOverlay() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.fillStyle = 'white';
      ctx.font = 'bold 48px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
      
      ctx.font = '24px Arial';
      ctx.fillText('Press ESC to Resume', canvas.width/2, canvas.height/2 + 50);
    }
    
    // Debug info
    function renderDebug() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillRect(10, 100, 300, 200);
      
      ctx.fillStyle = '#0F0';
      ctx.font = '12px monospace';
      ctx.textAlign = 'left';
      
      const info = [
        `Player: (${Math.round(game.player.x)}, ${Math.round(game.player.y)})`,
        `Zone: ${game.player.currentZone || 'none'}`,
        `Carrying: ${game.player.carrying || 'none'}`,
        `Plate: [${game.plate.join(', ')}]`,
        `State: ${game.state}`,
        `Score: ${game.score}/${CONFIG.WIN_SCORE} (Level ${game.level})`,
        `Timer: ${game.timer ? game.timer.toFixed(1) + 's' : 'none'}`,
        `Riddle: ${game.currentRiddle ? game.currentRiddle.id : 'none'}`,
        `Type: ${game.currentRiddle ? game.currentRiddle.type : 'none'}`,
        `Customer: ${game.currentCustomer ? game.currentCustomer.name : 'none'}`,
        `FPS: ${game.currentFPS}`,
        '',
        'Debug Commands (Console):',
        'debug.nextRiddle()',
        'debug.solveRiddle()',
        'debug.skipToLevel(2/3)',
        'debug.addScore(10)'
      ];
      
      info.forEach((line, i) => {
        ctx.fillText(line, 15, 120 + i * 15);
      });
      
      // Show hitboxes if enabled
      if (game.showHitboxes) {
        // Table zone
        ctx.strokeStyle = 'lime';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(KITCHEN.POSITIONS.TABLE.x, KITCHEN.POSITIONS.TABLE.y,
                KITCHEN.ZONES.TABLE_RADIUS, 0, Math.PI * 2);
        ctx.stroke();
        
        // Trash zone
        ctx.beginPath();
        ctx.arc(KITCHEN.POSITIONS.TRASH.x, KITCHEN.POSITIONS.TRASH.y,
                KITCHEN.ZONES.TRASH_RADIUS, 0, Math.PI * 2);
        ctx.stroke();
        
        // Bin zones
        for (let pos of Object.values(KITCHEN.POSITIONS.BINS)) {
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, KITCHEN.ZONES.BIN_RADIUS, 0, Math.PI * 2);
          ctx.stroke();
        }
        
        // Counter zone
        const counter = KITCHEN.POSITIONS.COUNTER;
        ctx.strokeRect(counter.x - KITCHEN.ZONES.COUNTER_WIDTH/2,
                      counter.y - KITCHEN.ZONES.COUNTER_HEIGHT/2 - 30,
                      KITCHEN.ZONES.COUNTER_WIDTH,
                      KITCHEN.ZONES.COUNTER_HEIGHT + 60);
      }
    }
    
    // Main render function
    function render() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw based on game state
      if (game.state === 'menu') {
        renderMenu();
      } else if (game.state === 'playing' || game.state === 'paused') {
        renderKitchen();
        renderCustomers(); // Phase 3 - Render customer sprites
        renderPlayer();
        renderUI();
        if (game.state === 'paused') {
          renderPauseOverlay();
        }
      } else if (game.state === 'won') {
        renderWinScreen();
      }
      
      // Debug info
      if (game.debugMode) {
        renderDebug();
      }
    }
    
    // =============================================================================
    // GAME LOOP & UPDATE
    // =============================================================================
    
    // Main update function
    function update(deltaTime) {
      if (game.state !== 'playing') return;
      
      // Update timer (Phase 2)
      if (game.currentRiddle) {
        game.timer -= deltaTime / 1000;
        if (game.timer <= 0) {
          game.timer = 0;
          // Clean timeout handling - no scramble, just clear message
          game.customerMessage = "TIMED OUT!!!";
          game.messageTimer = 2000;
          showToast("TIMED OUT!!!");
          console.log("TIMEOUT! Moving to next riddle...");
          AUDIO.playTimeout(); // Audio feedback
          game.plate = []; // Clear plate
          game.customerState = 'walking_out';
          setTimeout(() => nextRiddle(), 2500); // Give time for walking animation
        }
      }
      
      // Update player
      updatePlayer(deltaTime);
      
      // Update customer animation (Phase 5)
      updateCustomerAnimation(deltaTime);
      
      // Handle input
      if (input.wasPressed('e')) {
        handleInteraction();
      }
      
      if (input.wasPressed('q')) {
        handleUndo();
      }
      
      if (input.wasPressed('x')) {
        handleTrash();
      }
      
      if (input.wasPressed('enter')) {
        handleDelivery();
      }
      
      // Update timers
      if (game.toastTimer > 0) {
        game.toastTimer -= deltaTime;
      }
      if (game.messageTimer > 0) {
        game.messageTimer -= deltaTime;
      }
      if (game.deliveryDebounce > 0) {
        game.deliveryDebounce -= deltaTime;
      }
    }
    
    // FPS calculation
    function updateFPS(currentTime) {
      game.frameCount++;
      if (currentTime - game.lastFPSTime >= 1000) {
        game.currentFPS = game.frameCount;
        game.frameCount = 0;
        game.lastFPSTime = currentTime;
      }
    }
    
    // Main game loop
    function gameLoop(currentTime) {
      const deltaTime = currentTime - game.lastTime;
      game.lastTime = currentTime;
      
      // Update FPS
      updateFPS(currentTime);
      
      // Skip huge deltas (first frame, tab switch)
      if (deltaTime < 100) {
        update(deltaTime);
      }
      
      render();
      requestAnimationFrame(gameLoop);
    }
    
    // =============================================================================
    // GAME INITIALIZATION
    // =============================================================================
    
    // Start the game
    function startGame() {
      game.state = 'playing';
      game.score = 0;
      game.level = 1;
      game.timePerRiddle = CONFIG.LEVEL_1_TIME;
      game.plate = [];
      game.usedRiddles = [];
      game.customerIndex = 0;
      game.shuffledCustomers = shuffleCustomers(); // Randomize customer order each game
      game.player.carrying = null;
      
      // Get first riddle
      nextRiddle();
      
      console.log('üèõÔ∏è Order of the Gods - Dungeon of Mount Olympus trial begins!');
      showToast("The iron collar tightens... Your trial in the Feast Hall begins!");
    }
    
    // Initialize everything
    async function init() {
      console.log('üèõÔ∏è Initializing Order of the Gods - Dungeon of Mount Olympus...');
      
      // Check for mobile/small screen (updated for fullscreen experience)
      if (window.innerWidth < 1200 || window.innerHeight < 600) {
        document.querySelector('.mobile-warning').style.display = 'block';
        canvas.style.display = 'none';
        console.log('‚ùå Screen too small for fullscreen experience - game blocked');
        return;
      }
      
      // Load Phase 3 assets
      try {
        await loadAssets();
        console.log('üé® All assets loaded successfully!');
      } catch (error) {
        console.log('‚ö†Ô∏è Some assets failed to load, using fallbacks');
      }
      
      // Initialize input
      input.init();
      
      // Initialize audio system
      AUDIO.init();
      
      // Start at menu
      game.state = 'menu';
      
      // Debug commands (Phase 2)
      window.debug = {
        showState: () => console.log(game),
        addScore: (n) => { 
          game.score += n; 
          updateLevel();
          console.log(`Score: ${game.score}, Level: ${game.level}`); 
        },
        teleport: (x, y) => { 
          game.player.x = x; 
          game.player.y = y; 
          console.log(`Teleported to ${x}, ${y}`);
        },
        testCorners: () => {
          const corners = [
            { x: KITCHEN.BOUNDS.LEFT + 20, y: KITCHEN.BOUNDS.TOP + 20 },
            { x: KITCHEN.BOUNDS.RIGHT - 20, y: KITCHEN.BOUNDS.TOP + 20 },
            { x: KITCHEN.BOUNDS.LEFT + 20, y: KITCHEN.BOUNDS.BOTTOM - 20 },
            { x: KITCHEN.BOUNDS.RIGHT - 20, y: KITCHEN.BOUNDS.BOTTOM - 20 }
          ];
          
          let i = 0;
          const interval = setInterval(() => {
            if (i >= corners.length) {
              clearInterval(interval);
              debug.teleport(640, 360); // Return to center
              return;
            }
            debug.teleport(corners[i].x, corners[i].y);
            i++;
          }, 1000);
        },
        nextRiddle: () => { nextRiddle(); console.log('Skipped to next riddle'); },
        skipToLevel: (level) => {
          if (level === 2) debug.addScore(CONFIG.LEVEL_2_SCORE);
          else if (level === 3) debug.addScore(CONFIG.LEVEL_3_SCORE);
          else console.log('Level must be 2 or 3');
        },
        setTimer: (seconds) => { game.timer = seconds; console.log(`Timer set to ${seconds}s`); },
        solveRiddle: () => {
          if (!game.currentRiddle) return;
          // Auto-solve current riddle
          game.plate = [];
          if (game.currentRiddle.type === 'COUNT') {
            for (let [ingredient, count] of Object.entries(game.currentRiddle.counts)) {
              for (let i = 0; i < count; i++) {
                game.plate.push(ingredient);
              }
            }
          } else if (game.currentRiddle.type === 'SANDWICH') {
            game.plate = [...game.currentRiddle.sandwich];
          }
          console.log('Auto-solved riddle:', game.plate);
        },
        toggleAudio: () => { 
          AUDIO.enabled = !AUDIO.enabled; 
          console.log(`Audio ${AUDIO.enabled ? 'enabled' : 'disabled'}`);
        },
        win: () => { game.score = CONFIG.WIN_SCORE; game.state = 'won'; },
        start: () => startGame()
      };
      
      // Start game loop
      game.lastTime = performance.now();
      game.lastFPSTime = performance.now();
      requestAnimationFrame(gameLoop);
      
      console.log('‚úÖ Dungeon of Mount Olympus initialized! Press ENTER to begin your trial.');
      console.log('üí° Divine commands: debug.nextRiddle(), debug.solveRiddle(), debug.toggleAudio(), etc.');
      console.log('üèõÔ∏è Mythological features: Greek fonts, Crate storage, Walking gods & spirits!');
      console.log('‚ö±Ô∏è Ancient styling: Torchlight effects, Parchment riddles, Stone carvings!');
    }
    
    // Handle window resize for fullscreen experience
    function handleResize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      
      // Update dynamic positions
      KITCHEN.BOUNDS.RIGHT = window.innerWidth - 80;
      KITCHEN.BOUNDS.BOTTOM = window.innerHeight - 80;
      KITCHEN.CUSTOMER_AREA.BOTTOM = window.innerHeight - 80;
      KITCHEN.CUSTOMER_AREA.EXIT_Y = window.innerHeight - 100;
      KITCHEN.POSITIONS.TRASH.x = window.innerWidth - 150;
      KITCHEN.POSITIONS.TRASH.y = window.innerHeight - 150;
      KITCHEN.POSITIONS.COUNTER.x = Math.max(640, window.innerWidth * 0.5);
      KITCHEN.POSITIONS.TABLE.x = Math.max(640, window.innerWidth * 0.5);
      KITCHEN.POSITIONS.TABLE.y = Math.max(360, window.innerHeight * 0.4);
      KITCHEN.POSITIONS.BINS.cheese.x = window.innerWidth - 160;
      KITCHEN.POSITIONS.BINS.meat.x = window.innerWidth - 160;
      KITCHEN.POSITIONS.BINS.egg.x = Math.max(530, window.innerWidth * 0.4);
      KITCHEN.POSITIONS.BINS.egg.y = window.innerHeight - 180;
      KITCHEN.POSITIONS.BINS.pepper.x = Math.max(850, window.innerWidth * 0.6);
      KITCHEN.POSITIONS.BINS.pepper.y = window.innerHeight - 180;
      
      console.log(`üñ•Ô∏è Canvas resized to: ${canvas.width}x${canvas.height}`);
    }
    
    // Start when page loads
    window.addEventListener('load', init);
    window.addEventListener('resize', handleResize);
    
  </script>
</body>
</html>
