<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Order of the Gods</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #000;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      font-family: Arial, sans-serif;
      overflow: hidden;
    }
    canvas {
      border: 1px solid #333;
      background: #1a1a1a;
      cursor: none; /* Hide mouse cursor */
    }
    .mobile-warning {
      display: none;
      color: white;
      text-align: center;
      padding: 20px;
      font-size: 24px;
    }
    /* Block mobile and small screens */
    @media (max-width: 900px) {
      canvas { display: none !important; }
      .mobile-warning { display: block !important; }
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="1280" height="720"></canvas>
  <div class="mobile-warning">
    <h2>üñ•Ô∏è Laptop + Keyboard Required</h2>
    <p>This game requires a laptop or desktop computer with keyboard controls.</p>
    <p>WASD keys required for movement.</p>
  </div>

  <script>
    // =============================================================================
    // ORDER OF THE GODS - PHASE 1 IMPLEMENTATION
    // =============================================================================
    
    console.log("üèõÔ∏è Order of the Gods - Starting Phase 1...");
    
    // Get canvas and context
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // Verify canvas support
    if (!ctx) {
      alert('Your browser does not support Canvas. Please use Chrome, Firefox, or Safari.');
      throw new Error('Canvas not supported');
    }
    
    console.log(`‚úÖ Canvas initialized: ${canvas.width}x${canvas.height}`);
    
    // =============================================================================
    // CONSTANTS & CONFIGURATION
    // =============================================================================
    
    // EXACT KITCHEN LAYOUT COORDINATES (DO NOT CHANGE)
    const KITCHEN = {
      BOUNDS: {
        LEFT: 280,    // Kitchen area starts further right to make room for customers
        RIGHT: 1200, 
        TOP: 80,
        BOTTOM: 640
      },
      CUSTOMER_AREA: {
        LEFT: 50,     // Customer walking/waiting area
        RIGHT: 270,    
        TOP: 80,
        BOTTOM: 640,
        QUEUE_X: 200, // Where customers line up
        ENTRANCE_Y: 150, // Where customers enter from
        EXIT_Y: 550   // Where customers exit to
      },
      POSITIONS: {
        COUNTER: { x: 500, y: 120 },     // Moved counter into kitchen area
        TABLE: { x: 640, y: 360 },       // Central plate assembly
        TRASH: { x: 1050, y: 550 },      // Trash bin - bottom right corner
        BINS: {
          bread: { x: 360, y: 260 },     // Renamed and repositioned bins
          tomato: { x: 360, y: 460 },    
          cheese: { x: 1120, y: 260 },   
          meat: { x: 1120, y: 460 },     
          egg: { x: 530, y: 620 },       
          pepper: { x: 850, y: 620 }     
        }
      },
      ZONES: {
        TABLE_RADIUS: 90,        // Distance to interact with table
        BIN_RADIUS: 60,          // Distance to interact with bins
        TRASH_RADIUS: 50,        // Distance to interact with trash
        COUNTER_WIDTH: 360,      // Width of delivery zone
        COUNTER_HEIGHT: 40,      // Height of delivery zone
        INTERACTION_BUFFER: 8    // Extra pixels for generous collision
      }
    };
    
    // Game configuration
    const CONFIG = {
      PLAYER_SPEED: 5,           // Pixels per frame (300 px/sec at 60fps)
      PLAYER_SIZE: 32,           // Player square size
      MAX_PLATE_SIZE: 5,         // Maximum ingredients on plate
      MAX_CARRY: 1,              // Can only carry one ingredient
      
      // Timing
      LEVEL_1_TIME: 22,          // Seconds per riddle (level 1)
      LEVEL_2_TIME: 18,          // Seconds per riddle (level 2)
      LEVEL_3_TIME: 15,          // Seconds per riddle (level 3)
      
      // Progression
      LEVEL_2_SCORE: 10,         // Score needed for level 2
      LEVEL_3_SCORE: 20,         // Score needed for level 3
      WIN_SCORE: 30,             // Score needed to win
      
      // Visual
      COLORS: {
        PLAYER: '#FFD700',       // Gold
        BREAD: '#DEB887',        // Burlywood
        TOMATO: '#FF6347',       // Tomato red
        CHEESE: '#FFD700',       // Gold
        MEAT: '#8B0000',         // Dark red
        EGG: '#FFFACD',          // Lemon chiffon
        PEPPER: '#FF4500',       // Orange red
        TABLE: '#8B4513',        // Saddle brown
        COUNTER: '#696969',      // Dim gray
        WALL: '#4a4a4a',         // Gray
        FLOOR: '#2a2a2a'         // Dark gray
      }
    };
    
    console.log("‚úÖ Configuration loaded");
    
    // =============================================================================
    // ASSET LOADING SYSTEM (PHASE 3)
    // =============================================================================
    
    // Asset mapping and loading
    const ASSETS = {
      ingredients: {},
      customers: {},
      ui: {},
      loaded: false,
      totalAssets: 0,
      loadedAssets: 0
    };
    
    // Asset file mapping
    const ASSET_FILES = {
      ingredients: {
        bread: 'assets/bread.png',
        tomato: 'assets/tomato.png', 
        cheese: 'assets/cheese.png',
        meat: 'assets/meat.png',  // Updated to use meat.png
        egg: null, // No egg asset - will use placeholder
        pepper: 'assets/pepper.png'
      },
      customers: {
        medusa: 'assets/medusa.png',
        minotaur: 'assets/minotaur.png',
        hermes: 'assets/hermes.png',
        sphinx: 'assets/sphinx.png',
        pegasus: 'assets/pegasus.png'
      },
      ui: {
        plate: 'assets/plate.png'
      }
    };
    
    // Load image helper
    function loadImage(src) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => {
          ASSETS.loadedAssets++;
          console.log(`‚úÖ Loaded: ${src} (${ASSETS.loadedAssets}/${ASSETS.totalAssets})`);
          resolve(img);
        };
        img.onerror = () => {
          ASSETS.loadedAssets++;
          console.log(`‚ùå Failed: ${src}`);
          reject(new Error(`Failed to load ${src}`));
        };
        img.src = src;
      });
    }
    
    // Load all assets
    async function loadAssets() {
      console.log('üé® Loading Phase 3 assets...');
      
      const loadPromises = [];
      
      // Count total assets
      Object.values(ASSET_FILES.ingredients).forEach(src => src && ASSETS.totalAssets++);
      Object.values(ASSET_FILES.customers).forEach(src => src && ASSETS.totalAssets++);
      Object.values(ASSET_FILES.ui).forEach(src => src && ASSETS.totalAssets++);
      
      // Load ingredient assets
      for (let [ingredient, src] of Object.entries(ASSET_FILES.ingredients)) {
        if (src) {
          loadPromises.push(
            loadImage(src).then(img => {
              ASSETS.ingredients[ingredient] = img;
            }).catch(() => {
              console.log(`‚ö†Ô∏è Using fallback for ${ingredient}`);
              ASSETS.ingredients[ingredient] = null;
            })
          );
        } else {
          ASSETS.ingredients[ingredient] = null; // Will use fallback rendering
        }
      }
      
      // Load customer assets
      for (let [customer, src] of Object.entries(ASSET_FILES.customers)) {
        if (src) {
          loadPromises.push(
            loadImage(src).then(img => {
              ASSETS.customers[customer] = img;
            }).catch(() => {
              ASSETS.customers[customer] = null;
            })
          );
        }
      }
      
      // Load UI assets
      for (let [ui, src] of Object.entries(ASSET_FILES.ui)) {
        if (src) {
          loadPromises.push(
            loadImage(src).then(img => {
              ASSETS.ui[ui] = img;
            }).catch(() => {
              ASSETS.ui[ui] = null;
            })
          );
        }
      }
      
      // Wait for all assets to load
      await Promise.allSettled(loadPromises);
      
      ASSETS.loaded = true;
      console.log(`üé® Phase 3 assets loaded: ${ASSETS.loadedAssets}/${ASSETS.totalAssets}`);
      
      return ASSETS.loaded;
    }
    
    console.log("‚úÖ Asset system initialized");
    
    // =============================================================================
    // AUDIO SYSTEM (PHASE 3)
    // =============================================================================
    
    // Audio context and sound effects
    const AUDIO = {
      context: null,
      enabled: true,
      sounds: {},
      
      // Initialize audio context
      init() {
        try {
          this.context = new (window.AudioContext || window.webkitAudioContext)();
          console.log('üîä Audio system initialized');
        } catch (error) {
          console.log('‚ö†Ô∏è Audio not supported');
          this.enabled = false;
        }
      },
      
      // Create a simple beep sound
      createBeep(frequency, duration, type = 'sine') {
        if (!this.enabled || !this.context) return;
        
        const oscillator = this.context.createOscillator();
        const gainNode = this.context.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(this.context.destination);
        
        oscillator.frequency.value = frequency;
        oscillator.type = type;
        
        gainNode.gain.setValueAtTime(0.1, this.context.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);
        
        oscillator.start(this.context.currentTime);
        oscillator.stop(this.context.currentTime + duration);
      },
      
      // Play different sound effects
      playPickup() {
        this.createBeep(800, 0.1, 'square');
      },
      
      playPlace() {
        this.createBeep(600, 0.15, 'sine');
      },
      
      playDelivery() {
        this.createBeep(1000, 0.3, 'sine');
      },
      
      playSuccess() {
        // Success chord
        setTimeout(() => this.createBeep(523, 0.2), 0);   // C
        setTimeout(() => this.createBeep(659, 0.2), 100); // E
        setTimeout(() => this.createBeep(784, 0.3), 200); // G
      },
      
      playFailure() {
        this.createBeep(200, 0.5, 'sawtooth');
      },
      
      playTimeout() {
        // Timeout warning
        this.createBeep(400, 0.3, 'triangle');
        setTimeout(() => this.createBeep(300, 0.3), 150);
      },
      
      playLevelUp() {
        // Level up fanfare
        const notes = [523, 659, 784, 1047]; // C, E, G, C octave
        notes.forEach((freq, i) => {
          setTimeout(() => this.createBeep(freq, 0.2), i * 100);
        });
      },
      
      playTrash() {
        this.createBeep(300, 0.2, 'sawtooth');
      }
    };
    
    console.log("‚úÖ Audio system configured");
    
    // =============================================================================
    // RIDDLE & CUSTOMER DATABASE (PHASE 2)
    // =============================================================================
    
    // All riddles for the game
    const RIDDLES = [
      // LEVEL 1 - Simple COUNT riddles (22 seconds)
      { id: "l1_1", text: "Golden grain blessed by Demeter with vine's crimson blood", type: "COUNT", level: 1, 
        counts: { bread: 1, tomato: 1 }},
      { id: "l1_2", text: "Hunter's prize paired with the cow's sacred gift", type: "COUNT", level: 1,
        counts: { meat: 1, cheese: 1 }},
      { id: "l1_3", text: "Zeus's forbidden treasure touched by flame's essence", type: "COUNT", level: 1,
        counts: { egg: 1, pepper: 1 }},
      { id: "l1_4", text: "Twin grains with single crimson orb", type: "COUNT", level: 1,
        counts: { bread: 2, tomato: 1 }},
      { id: "l1_5", text: "Double moon's gift crowning the beast", type: "COUNT", level: 1,
        counts: { cheese: 2, meat: 1 }},
      { id: "l1_6", text: "Sacred envelope: grain embraces cow's craft", type: "SANDWICH", level: 1,
        sandwich: ["bread", "cheese", "bread"]},
      { id: "l1_7", text: "Divine cradle: bread shelters vine's blood", type: "SANDWICH", level: 1,
        sandwich: ["bread", "tomato", "bread"]},
      { id: "l1_8", text: "Trinity of lunar discs", type: "COUNT", level: 1,
        counts: { cheese: 3 }},
      
      // LEVEL 2 - Divine EXCLUDE riddles (18 seconds)
      { id: "l2_1", text: "Blood and beast unite, but Zeus's egg brings doom", type: "EXCLUDE", level: 2,
        counts: { tomato: 1, meat: 1 }, exclude: ["egg"]},
      { id: "l2_2", text: "Double hunter's bounty, but moon's gift is forbidden", type: "EXCLUDE", level: 2,
        counts: { meat: 2 }, exclude: ["cheese"]},
      { id: "l2_3", text: "Fire and moon collide, but crimson blood is cursed", type: "EXCLUDE", level: 2,
        counts: { cheese: 1, pepper: 1 }, exclude: ["tomato"]},
      { id: "l2_4", text: "Twin lunar gifts blessing single crimson orb", type: "COUNT", level: 2,
        counts: { cheese: 2, tomato: 1 }},
      { id: "l2_5", text: "Warrior's meal: grain shields the hunter's prize", type: "SANDWICH", level: 2,
        sandwich: ["bread", "meat", "bread"]},
      { id: "l2_6", text: "Trio of vine's sacred blood", type: "COUNT", level: 2,
        counts: { tomato: 3 }},
      
      // LEVEL 3 - Legendary challenges (15 seconds)
      { id: "l3_1", text: "Trinity of power: grain, beast, crimson blood", type: "COUNT", level: 3,
        counts: { bread: 1, meat: 1, tomato: 1 }},
      { id: "l3_2", text: "Sacred triad: hunter's prize, moon's gift, flame's kiss", type: "COUNT", level: 3,
        counts: { meat: 1, cheese: 1, pepper: 1 }},
      { id: "l3_3", text: "Twin moons reign supreme, but fire is banished", type: "EXCLUDE", level: 3,
        counts: { cheese: 2 }, exclude: ["pepper"]},
      { id: "l3_4", text: "Inferno trapped in golden walls", type: "SANDWICH", level: 3,
        sandwich: ["bread", "pepper", "bread"]},
      { id: "l3_5", text: "Double beast blessing single flame", type: "COUNT", level: 3,
        counts: { meat: 2, pepper: 1 }},
      { id: "l3_6", text: "Hermes' perfect harmony: grain, blood, moon, beast", type: "COUNT", level: 3,
        counts: { bread: 1, tomato: 1, cheese: 1, meat: 1 }},
      { id: "l3_7", text: "Fill the divine plate completely with five sacred offerings", type: "TOTALCOUNT", level: 3,
        totalCount: 5},
      { id: "l3_8", text: "Medusa's challenge: All different, nothing repeated", type: "UNIQUE", level: 3,
        totalCount: 4, uniqueOnly: true}
    ];
    
    // Customer database
    const CUSTOMERS = [
      { id: "minotaur", name: "Minotaur", 
        success: ["The labyrinth rests.", "Straight through.", "Your path is clear."],
        failure: ["Lost already?", "Wrong turn taken.", "The maze claims you."], 
        timeout: ["The maze does not wait.", "Time traps the lost.", "Choose swiftly."]},
      { id: "medusa", name: "Medusa",
        success: ["Stone-cold perfect.", "Acceptable gaze.", "Your eyes see truth."],
        failure: ["You froze.", "Turned to failure.", "Gaze upon your mistake."],
        timeout: ["Petrified by seconds?", "Time turns you to stone.", "Hesitation kills."]},
      { id: "hermes", name: "Hermes",
        success: ["Swift and sure.", "Wings approved.", "Speed and precision unite."],
        failure: ["Outpaced again.", "Too slow, mortal.", "Haste without thought."],
        timeout: ["Wings beat you.", "Swift time escapes.", "The messenger departs."]},
      { id: "sphinx", name: "Sphinx",
        success: ["Your mind is awake.", "The riddle yields.", "Wisdom is shown."],
        failure: ["Answer me properly.", "Your mind falters.", "Think harder, mortal."],
        timeout: ["Silence is not an answer.", "Time riddles all.", "The sphinx waits not."]},
      { id: "pegasus", name: "Pegasus",
        success: ["Wings of satisfaction.", "Sky-high approval.", "Divine flight achieved."],
        failure: ["Grounded by error.", "Wings clipped.", "Fall from grace."],
        timeout: ["Time flies away.", "Swift as wind departs.", "The sky cannot wait."]},
      { id: "ghost", name: "Restless Spirit",
        success: ["The veil shivers.", "Peace flows.", "Rest is granted."],
        failure: ["Whispers say no.", "Unrest grows.", "The dead are displeased."],
        timeout: ["Time slipped through you.", "Eternity waits not.", "The spirit fades."]}
    ];
    
    // Randomize customer order for each game
    function shuffleCustomers() {
      const shuffled = [...CUSTOMERS];
      for (let i = shuffled.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
      }
      return shuffled;
    }
    
    console.log(`‚úÖ Loaded ${RIDDLES.length} riddles and ${CUSTOMERS.length} customers`);
    
    // =============================================================================
    // GAME STATE
    // =============================================================================
    
    // Main game state object
    const game = {
      // Game flow
      state: 'menu',              // 'menu', 'playing', 'paused', 'won'
      score: 0,
      level: 1,
      
      // Player
      player: {
        x: 640,                   // Start at table center
        y: 360,
        carrying: null,           // null or ingredient name string
        currentZone: null,        // Which interaction zone player is in
        speed: CONFIG.PLAYER_SPEED
      },
      
      // Plate & ingredients
      plate: [],                  // Array of ingredient strings, max 5
      
      // Riddle system
      currentRiddle: null,        // Current riddle object
      riddleIndex: 0,             // Track which riddle we're on
      usedRiddles: [],            // Track used riddles to avoid repeats
      
      // Customer system
      currentCustomer: null,      // Current customer object
      customerIndex: 0,           // Rotation index
      customerMessage: '',        // What customer is saying
      messageTimer: 0,            // How long to show message
      shuffledCustomers: [],      // Randomized customer order
      customerPosition: { x: 0, y: 0 }, // Current customer position
      customerState: 'walking_in',    // 'walking_in', 'waiting', 'walking_out'
      customerAnimation: 0,           // Animation frame counter
      
      // Timing
      timer: CONFIG.LEVEL_1_TIME, // Current timer
      timePerRiddle: CONFIG.LEVEL_1_TIME,
      lastTime: 0,                // For delta time
      deliveryDebounce: 0,        // Prevent double delivery
      
      // Feedback
      toastMessage: '',           // Current toast message
      toastTimer: 0,              // How long to show toast
      
      // Debug
      debugMode: false,
      showHitboxes: false,
      frameCount: 0,
      lastFPSTime: 0,
      currentFPS: 60
    };
    
    console.log("‚úÖ Game state initialized:", game);
    
    // =============================================================================
    // INPUT SYSTEM (KEYBOARD ONLY)
    // =============================================================================
    
    const input = {
      keys: {},
      keyPressed: {}, // Track single presses to prevent repeats
      
      init() {
        // Keydown handler
        document.addEventListener('keydown', (e) => {
          const key = e.key.toLowerCase();
          this.keys[key] = true;
          
          // Prevent defaults for game keys
          if (['w','a','s','d','e','q','x','enter','escape'].includes(key)) {
            e.preventDefault();
          }
          
          // Special keys
          if (key === 'escape' && game.state === 'playing') {
            game.state = 'paused';
            console.log("Game paused");
          } else if (key === 'escape' && game.state === 'paused') {
            game.state = 'playing';
            console.log("Game resumed");
          }
          
          // Debug keys
          if (key === '`' || key === '~') {
            game.debugMode = !game.debugMode;
            console.log('Debug mode:', game.debugMode);
          }
          
          if (key === 'f1' && game.debugMode) {
            game.showHitboxes = !game.showHitboxes;
            console.log('Show hitboxes:', game.showHitboxes);
          }
        });
        
        // Keyup handler
        document.addEventListener('keyup', (e) => {
          const key = e.key.toLowerCase();
          this.keys[key] = false;
          this.keyPressed[key] = false;
        });
        
        // Window blur (auto-pause)
        window.addEventListener('blur', () => {
          this.keys = {}; // Clear all keys
          this.keyPressed = {};
          if (game.state === 'playing') {
            game.state = 'paused';
            console.log("Game auto-paused (window blur)");
          }
        });
        
        console.log('‚úÖ Input system initialized');
      },
      
      // Check if key is currently pressed
      isPressed(key) {
        return !!this.keys[key.toLowerCase()];
      },
      
      // Check if key was just pressed (single press)
      wasPressed(key) {
        const k = key.toLowerCase();
        if (this.keys[k] && !this.keyPressed[k]) {
          this.keyPressed[k] = true;
          return true;
        }
        return false;
      },
      
      // Get movement vector (normalized for diagonal)
      getMovementVector() {
        let x = 0, y = 0;
        
        if (this.isPressed('a')) x -= 1;
        if (this.isPressed('d')) x += 1;
        if (this.isPressed('w')) y -= 1;
        if (this.isPressed('s')) y += 1;
        
        // Normalize diagonal movement
        if (x !== 0 && y !== 0) {
          x *= 0.707; // 1/sqrt(2)
          y *= 0.707;
        }
        
        return { x, y };
      }
    };
    
    // =============================================================================
    // UTILITY FUNCTIONS
    // =============================================================================
    
    // Distance helper
    function distance(x1, y1, x2, y2) {
      return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
    }
    
    // Random choice helper
    function randomChoice(array) {
      return array[Math.floor(Math.random() * array.length)];
    }
    
    // Toast message system
    function showToast(message) {
      game.toastMessage = message;
      game.toastTimer = 2000; // Show for 2 seconds
      console.log(`Toast: ${message}`);
    }
    
    // =============================================================================
    // RIDDLE VALIDATION SYSTEM (PHASE 2)
    // =============================================================================
    
    // Validate plate against riddle
    function validatePlate(plate, riddle) {
      if (!riddle) return { success: false, reason: "No active riddle" };
      
      // COUNT validation
      if (riddle.type === "COUNT") {
        const plateCounts = {};
        plate.forEach(item => {
          plateCounts[item] = (plateCounts[item] || 0) + 1;
        });
        
        // Check exact matches
        for (let ingredient in riddle.counts) {
          if (plateCounts[ingredient] !== riddle.counts[ingredient]) {
            return { success: false, reason: "Wrong ingredients" };
          }
        }
        
        // Check no extras
        for (let ingredient in plateCounts) {
          if (!riddle.counts[ingredient]) {
            return { success: false, reason: "Extra ingredients" };
          }
        }
        
        return { success: true };
      }
      
      // EXCLUDE validation
      if (riddle.type === "EXCLUDE") {
        const plateCounts = {};
        plate.forEach(item => {
          plateCounts[item] = (plateCounts[item] || 0) + 1;
        });
        
        // Check excluded items
        for (let excluded of riddle.exclude || []) {
          if (plateCounts[excluded] > 0) {
            return { success: false, reason: `Contains ${excluded}!` };
          }
        }
        
        // Check required items
        for (let ingredient in riddle.counts) {
          if (plateCounts[ingredient] !== riddle.counts[ingredient]) {
            return { success: false, reason: "Wrong ingredients" };
          }
        }
        
        return { success: true };
      }
      
      // SANDWICH validation
      if (riddle.type === "SANDWICH") {
        if (plate.length !== riddle.sandwich.length) {
          return { success: false, reason: `Need exactly ${riddle.sandwich.length} items` };
        }
        
        for (let i = 0; i < riddle.sandwich.length; i++) {
          if (plate[i] !== riddle.sandwich[i]) {
            return { success: false, reason: "Wrong sandwich order" };
          }
        }
        
        return { success: true };
      }
      
      // TOTALCOUNT validation (Phase 4 - New type)
      if (riddle.type === "TOTALCOUNT") {
        if (plate.length !== riddle.totalCount) {
          return { success: false, reason: `Need exactly ${riddle.totalCount} items` };
        }
        
        return { success: true };
      }
      
      // UNIQUE validation (Phase 4 - New type)
      if (riddle.type === "UNIQUE") {
        if (plate.length !== riddle.totalCount) {
          return { success: false, reason: `Need exactly ${riddle.totalCount} items` };
        }
        
        const uniqueItems = new Set(plate);
        if (uniqueItems.size !== plate.length) {
          return { success: false, reason: "All items must be different!" };
        }
        
        return { success: true };
      }
      
      return { success: false, reason: "Unknown riddle type" };
    }
    
    // Get next riddle
    function nextRiddle() {
      // Get riddles for current level
      const levelRiddles = RIDDLES.filter(r => r.level === game.level);
      
      // Avoid repeats
      const available = levelRiddles.filter(r => !game.usedRiddles.includes(r.id));
      
      if (available.length === 0) {
        // Reset if we've used all riddles
        game.usedRiddles = [];
        nextRiddle();
        return;
      }
      
      // Pick random riddle
      game.currentRiddle = randomChoice(available);
      game.usedRiddles.push(game.currentRiddle.id);
      
      // Reset timer
      game.timer = game.timePerRiddle;
      
      // Get next customer from shuffled order
      if (game.shuffledCustomers.length === 0) {
        game.shuffledCustomers = shuffleCustomers();
      }
      game.currentCustomer = game.shuffledCustomers[game.customerIndex % game.shuffledCustomers.length];
      game.customerIndex++;
      game.customerMessage = '';
      game.messageTimer = 0;
      
      // Reset customer animation
      game.customerState = 'walking_in';
      game.customerPosition.x = KITCHEN.CUSTOMER_AREA.LEFT;
      game.customerPosition.y = KITCHEN.CUSTOMER_AREA.ENTRANCE_Y;
      game.customerAnimation = 0;
      
      // Clear plate
      game.plate = [];
      
      console.log(`New riddle: ${game.currentRiddle.text} (${game.currentRiddle.type}) - ${game.timer}s`);
    }
    
    // Update level based on score
    function updateLevel() {
      const prevLevel = game.level;
      
      if (game.score >= CONFIG.LEVEL_3_SCORE) {
        game.level = 3;
        game.timePerRiddle = CONFIG.LEVEL_3_TIME;
      } else if (game.score >= CONFIG.LEVEL_2_SCORE) {
        game.level = 2;
        game.timePerRiddle = CONFIG.LEVEL_2_TIME;
      }
      
      if (game.level > prevLevel) {
        showToast(`SPEED UP! Level ${game.level}`);
        console.log(`Level up to ${game.level}! Time per riddle: ${game.timePerRiddle}s`);
        AUDIO.playLevelUp(); // Phase 3 - Audio feedback
      }
    }
    
    // =============================================================================
    // COLLISION & ZONE DETECTION
    // =============================================================================
    
    // Check what zone the player is in
    function updatePlayerZone() {
      const player = game.player;
      const prevZone = player.currentZone;
      player.currentZone = null;
      
      // Check table zone (circular)
      const tableDist = distance(player.x, player.y, 
                                KITCHEN.POSITIONS.TABLE.x, 
                                KITCHEN.POSITIONS.TABLE.y);
      if (tableDist < KITCHEN.ZONES.TABLE_RADIUS) {
        player.currentZone = 'table';
        return;
      }
      
      // Check counter/delivery zone (rectangular)
      const counter = KITCHEN.POSITIONS.COUNTER;
      if (Math.abs(player.x - counter.x) < KITCHEN.ZONES.COUNTER_WIDTH/2 &&
          Math.abs(player.y - counter.y) < KITCHEN.ZONES.COUNTER_HEIGHT/2 + 30) {
        player.currentZone = 'counter';
        return;
      }
      
      // Check trash zone (circular)
      const trashDist = distance(player.x, player.y, 
                                KITCHEN.POSITIONS.TRASH.x, 
                                KITCHEN.POSITIONS.TRASH.y);
      if (trashDist < KITCHEN.ZONES.TRASH_RADIUS) {
        player.currentZone = 'trash';
        return;
      }
      
      // Check ingredient bins (circular)
      for (let [ingredient, pos] of Object.entries(KITCHEN.POSITIONS.BINS)) {
        const dist = distance(player.x, player.y, pos.x, pos.y);
        if (dist < KITCHEN.ZONES.BIN_RADIUS) {
          player.currentZone = `bin_${ingredient.toLowerCase()}`;
          return;
        }
      }
      
      // Log zone changes for debugging
      if (prevZone !== player.currentZone && game.debugMode) {
        console.log(`Zone change: ${prevZone} ‚Üí ${player.currentZone}`);
      }
    }
    
    // =============================================================================
    // CUSTOMER ANIMATION SYSTEM (PHASE 5)
    // =============================================================================
    
    // Update customer walking animation
    function updateCustomerAnimation(deltaTime) {
      if (!game.currentCustomer) return;
      
      const animSpeed = 2; // pixels per frame
      game.customerAnimation += deltaTime;
      
      if (game.customerState === 'walking_in') {
        // Walk from entrance to queue position
        game.customerPosition.x += animSpeed;
        if (game.customerPosition.x >= KITCHEN.CUSTOMER_AREA.QUEUE_X) {
          game.customerPosition.x = KITCHEN.CUSTOMER_AREA.QUEUE_X;
          game.customerState = 'waiting';
        }
      } else if (game.customerState === 'walking_out') {
        // Walk from queue to exit
        game.customerPosition.y += animSpeed;
        if (game.customerPosition.y >= KITCHEN.CUSTOMER_AREA.EXIT_Y) {
          game.customerPosition.y = KITCHEN.CUSTOMER_AREA.EXIT_Y;
          game.customerState = 'gone';
        }
      }
    }
    
    // =============================================================================
    // PLAYER MECHANICS
    // =============================================================================
    
    // Player movement update
    function updatePlayer(deltaTime) {
      if (game.state !== 'playing') return;
      
      const movement = input.getMovementVector();
      const player = game.player;
      
      // Calculate new position
      const newX = player.x + (movement.x * player.speed);
      const newY = player.y + (movement.y * player.speed);
      
      // Apply boundaries
      const halfSize = CONFIG.PLAYER_SIZE / 2;
      player.x = Math.max(KITCHEN.BOUNDS.LEFT + halfSize,
                         Math.min(KITCHEN.BOUNDS.RIGHT - halfSize, newX));
      player.y = Math.max(KITCHEN.BOUNDS.TOP + halfSize,
                         Math.min(KITCHEN.BOUNDS.BOTTOM - halfSize, newY));
      
      // Update current zone
      updatePlayerZone();
    }
    
    // Pickup/place mechanics
    function handleInteraction() {
      const player = game.player;
      const zone = player.currentZone;
      
      if (!zone) {
        showToast("Nothing here to interact with");
        return;
      }
      
      // At ingredient bin
      if (zone.startsWith('bin_')) {
        const ingredient = zone.replace('bin_', '');
        
        if (player.carrying) {
          showToast("Hands full!");
        } else {
          player.carrying = ingredient;
          showToast(`Picked up ${ingredient}`);
          console.log(`Picked up: ${ingredient}`);
          AUDIO.playPickup(); // Phase 3 - Audio feedback
        }
      }
      
      // At table
      else if (zone === 'table') {
        if (player.carrying) {
          if (game.plate.length >= CONFIG.MAX_PLATE_SIZE) {
            showToast("Plate is full!");
          } else {
            game.plate.push(player.carrying);
            showToast(`Placed ${player.carrying}`);
            console.log(`Plate now: ${game.plate.join(', ')}`);
            player.carrying = null;
            AUDIO.playPlace(); // Phase 3 - Audio feedback
          }
        } else {
          showToast("Pick up an ingredient first");
        }
      }
    }
    
    // Undo function (Q key at table)
    function handleUndo() {
      if (game.player.currentZone !== 'table') {
        showToast("Go to table to undo");
        return;
      }
      
      if (game.plate.length === 0) {
        showToast("Nothing to undo");
        return;
      }
      
      const removed = game.plate.pop();
      showToast(`Removed ${removed}`);
      console.log(`Undid ${removed}, plate now: ${game.plate.join(', ')}`);
      AUDIO.playPlace(); // Phase 3 - Audio feedback (same as place, but reversed)
    }
    
    // Trash function (X key at trash)
    function handleTrash() {
      if (game.player.currentZone !== 'trash') {
        showToast("Go to trash bin to discard");
        return;
      }
      
      if (!game.player.carrying) {
        showToast("Nothing to trash");
        return;
      }
      
      const trashed = game.player.carrying;
      game.player.carrying = null;
      showToast(`Trashed ${trashed}`);
      console.log(`Trashed: ${trashed}`);
      AUDIO.playTrash(); // Phase 3 - Audio feedback
    }
    
    // Delivery function (Phase 2 - Real validation)
    function handleDelivery() {
      if (game.player.currentZone !== 'counter') {
        showToast("Go to counter to deliver");
        return;
      }
      
      if (game.deliveryDebounce > 0) return; // Prevent double delivery
      
      if (game.plate.length === 0) {
        showToast("Nothing to serve");
        return;
      }
      
      // Validate the plate
      const result = validatePlate(game.plate, game.currentRiddle);
      
      if (result.success) {
        // Success!
        game.score++;
        game.customerMessage = randomChoice(game.currentCustomer.success);
        game.messageTimer = 2000;
        showToast("Correct! +1 point");
        console.log(`SUCCESS! Score: ${game.score}`);
        AUDIO.playSuccess(); // Phase 3 - Audio feedback
        
        // Check for level up
        updateLevel();
        
        // Check for win
        if (game.score >= CONFIG.WIN_SCORE) {
          game.state = 'won';
          console.log("GAME WON!");
          return;
        }
        
        // Customer walks out, then next riddle
        game.customerState = 'walking_out';
        setTimeout(() => nextRiddle(), 2500); // Give time for walking animation
      } else {
        // Failure
        game.customerMessage = randomChoice(game.currentCustomer.failure);
        game.messageTimer = 2000;
        showToast(`Wrong! ${result.reason}`);
        console.log(`FAILED: ${result.reason}`);
        AUDIO.playFailure(); // Phase 3 - Audio feedback
        
        // Customer walks out after feedback, then next riddle
        game.customerState = 'walking_out';
        setTimeout(() => nextRiddle(), 2500); // Give time for walking animation
      }
      
      // Clear plate and set debounce
      game.plate = [];
      game.deliveryDebounce = 300;
    }
    
    // =============================================================================
    // RENDERING SYSTEM
    // =============================================================================
    
    // Render kitchen layout
    function renderKitchen() {
      // Floor
      ctx.fillStyle = CONFIG.COLORS.FLOOR;
      ctx.fillRect(KITCHEN.BOUNDS.LEFT, KITCHEN.BOUNDS.TOP,
                   KITCHEN.BOUNDS.RIGHT - KITCHEN.BOUNDS.LEFT,
                   KITCHEN.BOUNDS.BOTTOM - KITCHEN.BOUNDS.TOP);
      
      // Walls
      ctx.fillStyle = CONFIG.COLORS.WALL;
      ctx.fillRect(0, 0, canvas.width, KITCHEN.BOUNDS.TOP); // Top
      ctx.fillRect(0, KITCHEN.BOUNDS.BOTTOM, canvas.width, canvas.height); // Bottom
      ctx.fillRect(0, 0, KITCHEN.BOUNDS.LEFT, canvas.height); // Left
      ctx.fillRect(KITCHEN.BOUNDS.RIGHT, 0, canvas.width, canvas.height); // Right
      
      // Ingredient bins (Phase 5 - Optimized size and appearance)
      const binSize = 90; // Optimized size for better PNG visibility
      for (let [ingredient, pos] of Object.entries(KITCHEN.POSITIONS.BINS)) {
        
        // Enhanced bin background with gradient
        const binGradient = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, binSize/2);
        binGradient.addColorStop(0, '#8B4513'); // Saddle brown
        binGradient.addColorStop(1, '#654321'); // Dark brown
        ctx.fillStyle = binGradient;
        ctx.fillRect(pos.x - binSize/2, pos.y - binSize/2, binSize, binSize);
        
        // Bin border with better contrast
        ctx.strokeStyle = '#2F1B14';
        ctx.lineWidth = 3;
        ctx.strokeRect(pos.x - binSize/2, pos.y - binSize/2, binSize, binSize);
        
        // Draw ingredient PNG if available
        const ingredientImg = ASSETS.ingredients[ingredient];
        if (ingredientImg && ASSETS.loaded) {
          const imgSize = 60; // Larger ingredient images for better visibility
          ctx.drawImage(
            ingredientImg, 
            pos.x - imgSize/2, 
            pos.y - imgSize/2 - 8, // More space for label
            imgSize, 
            imgSize
          );
        } else {
          // Enhanced fallback graphics
          ctx.fillStyle = CONFIG.COLORS[ingredient.toUpperCase()];
          ctx.fillRect(pos.x - 30, pos.y - 30, 60, 60);
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 2;
          ctx.strokeRect(pos.x - 30, pos.y - 30, 60, 60);
        }
        
        // Enhanced label with better styling
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(pos.x - 40, pos.y + 25, 80, 22);
        
        // Label border
        ctx.strokeStyle = '#654321';
        ctx.lineWidth = 1;
        ctx.strokeRect(pos.x - 40, pos.y + 25, 80, 22);
        
        // Label text with better styling
        ctx.fillStyle = '#FFD700';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 1;
        ctx.strokeText(ingredient.toUpperCase(), pos.x, pos.y + 40);
        ctx.fillText(ingredient.toUpperCase(), pos.x, pos.y + 40);
        
        // Enhanced highlight when player is near
        if (game.player.currentZone === `bin_${ingredient.toLowerCase()}`) {
          ctx.strokeStyle = '#FFD700';
          ctx.lineWidth = 5;
          ctx.setLineDash([]);
          ctx.shadowColor = '#FFD700';
          ctx.shadowBlur = 15;
          ctx.strokeRect(pos.x - binSize/2 - 5, pos.y - binSize/2 - 5, 
                        binSize + 10, binSize + 10);
          ctx.shadowBlur = 0;
        }
      }
      
      // Table (Phase 3 - Enhanced with plate asset)
      const table = KITCHEN.POSITIONS.TABLE;
      
      // Table surface
      ctx.fillStyle = CONFIG.COLORS.TABLE;
      ctx.fillRect(table.x - 120, table.y - 80, 240, 160);
      ctx.strokeStyle = '#654321';
      ctx.lineWidth = 4;
      ctx.strokeRect(table.x - 120, table.y - 80, 240, 160);
      
      // Enhanced table surface (no plate PNG)
      ctx.fillStyle = '#F5F5DC'; // Beige table surface
      ctx.beginPath();
      ctx.arc(table.x, table.y, 80, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = '#DDD';
      ctx.lineWidth = 3;
      ctx.stroke();
      
      // Add table texture pattern
      ctx.strokeStyle = '#E6E6E6';
      ctx.lineWidth = 1;
      ctx.setLineDash([5, 5]);
      ctx.beginPath();
      ctx.arc(table.x, table.y, 60, 0, Math.PI * 2);
      ctx.stroke();
      ctx.beginPath();
      ctx.arc(table.x, table.y, 40, 0, Math.PI * 2);
      ctx.stroke();
      ctx.setLineDash([]);
      
      // Ingredient slots on plate (Phase 3 - Show PNG ingredients)
      for (let i = 0; i < 5; i++) {
        const angle = (i * Math.PI * 2) / 5 - Math.PI/2; // Start at top, go clockwise
        const radius = 35; // Distance from center
        const slotX = table.x + Math.cos(angle) * radius;
        const slotY = table.y + Math.sin(angle) * radius;
        
        // Draw ingredient on plate if present
        if (game.plate[i]) {
          const ingredientImg = ASSETS.ingredients[game.plate[i]];
          if (ingredientImg && ASSETS.loaded) {
            const imgSize = 25;
            ctx.drawImage(
              ingredientImg,
              slotX - imgSize/2,
              slotY - imgSize/2,
              imgSize,
              imgSize
            );
          } else {
            // Fallback to colored circle
            ctx.fillStyle = CONFIG.COLORS[game.plate[i].toUpperCase()];
            ctx.beginPath();
            ctx.arc(slotX, slotY, 12, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1;
            ctx.stroke();
          }
        } else {
          // Empty slot indicator
          ctx.strokeStyle = '#CCC';
          ctx.lineWidth = 1;
          ctx.setLineDash([3, 3]);
          ctx.beginPath();
          ctx.arc(slotX, slotY, 12, 0, Math.PI * 2);
          ctx.stroke();
          ctx.setLineDash([]);
        }
      }
      
      // Highlight table if player is near
      if (game.player.currentZone === 'table') {
        ctx.strokeStyle = '#FFD700';
        ctx.lineWidth = 3;
        ctx.strokeRect(table.x - 105, table.y - 65, 210, 130);
      }
      
      // Counter/delivery zone
      const counter = KITCHEN.POSITIONS.COUNTER;
      ctx.fillStyle = CONFIG.COLORS.COUNTER;
      ctx.fillRect(counter.x - 180, counter.y - 20, 360, 40);
      ctx.strokeStyle = '#2F4F4F';
      ctx.lineWidth = 3;
      ctx.strokeRect(counter.x - 180, counter.y - 20, 360, 40);
      
      // Delivery zone indicator
      if (game.player.currentZone === 'counter') {
        ctx.strokeStyle = '#FFD700';
        ctx.lineWidth = 3;
        ctx.setLineDash([5, 5]);
        ctx.strokeRect(counter.x - 175, counter.y - 15, 350, 30);
        ctx.setLineDash([]);
      }
      
      // Trash bin
      const trash = KITCHEN.POSITIONS.TRASH;
      const trashSize = 50;
      
      // Trash bin body (dark gray)
      ctx.fillStyle = '#404040';
      ctx.fillRect(trash.x - trashSize/2, trash.y - trashSize/2, trashSize, trashSize);
      
      // Trash bin lid (lighter gray)
      ctx.fillStyle = '#606060';
      ctx.fillRect(trash.x - trashSize/2 - 5, trash.y - trashSize/2 - 8, trashSize + 10, 15);
      
      // Trash bin border
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.strokeRect(trash.x - trashSize/2, trash.y - trashSize/2, trashSize, trashSize);
      ctx.strokeRect(trash.x - trashSize/2 - 5, trash.y - trashSize/2 - 8, trashSize + 10, 15);
      
      // Trash icon/lines
      ctx.strokeStyle = '#888';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(trash.x - 15, trash.y - 10);
      ctx.lineTo(trash.x - 15, trash.y + 15);
      ctx.moveTo(trash.x, trash.y - 10);
      ctx.lineTo(trash.x, trash.y + 15);
      ctx.moveTo(trash.x + 15, trash.y - 10);
      ctx.lineTo(trash.x + 15, trash.y + 15);
      ctx.stroke();
      
      // Highlight if player is near
      if (game.player.currentZone === 'trash') {
        ctx.strokeStyle = '#FFD700';
        ctx.lineWidth = 3;
        ctx.strokeRect(trash.x - trashSize/2 - 5, trash.y - trashSize/2 - 5, 
                      trashSize + 10, trashSize + 10);
      }
      
      // Labels
      ctx.fillStyle = '#FFF';
      ctx.font = 'bold 14px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('TABLE', table.x, table.y - 75);
      ctx.fillText('DELIVERY COUNTER', counter.x, counter.y - 30);
      ctx.fillText('TRASH', trash.x, trash.y + 40);
    }
    
    // Render player (Phase 3 - Enhanced with carried item PNG)
    function renderPlayer() {
      const player = game.player;
      
      // Player square
      ctx.fillStyle = CONFIG.COLORS.PLAYER;
      ctx.fillRect(player.x - CONFIG.PLAYER_SIZE/2,
                   player.y - CONFIG.PLAYER_SIZE/2,
                   CONFIG.PLAYER_SIZE, CONFIG.PLAYER_SIZE);
      
      // Player border
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.strokeRect(player.x - CONFIG.PLAYER_SIZE/2,
                     player.y - CONFIG.PLAYER_SIZE/2,
                     CONFIG.PLAYER_SIZE, CONFIG.PLAYER_SIZE);
      
      // Carried item (Phase 5 - Enhanced appearance)
      if (player.carrying) {
        const carriedImg = ASSETS.ingredients[player.carrying];
        if (carriedImg && ASSETS.loaded) {
          // Draw ingredient PNG above player with better size
          const imgSize = 40; // Slightly larger for better visibility
          
          // Add background circle for contrast
          ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
          ctx.beginPath();
          ctx.arc(player.x, player.y - CONFIG.PLAYER_SIZE/2 - imgSize/2 - 8, imgSize/2 + 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.strokeStyle = '#FFD700';
          ctx.lineWidth = 2;
          ctx.stroke();
          
          // Draw the ingredient image
          ctx.drawImage(
            carriedImg,
            player.x - imgSize/2,
            player.y - CONFIG.PLAYER_SIZE/2 - imgSize - 8,
            imgSize,
            imgSize
          );
          
          // Add golden glow effect
          ctx.shadowColor = '#FFD700';
          ctx.shadowBlur = 8;
          ctx.drawImage(
            carriedImg,
            player.x - imgSize/2,
            player.y - CONFIG.PLAYER_SIZE/2 - imgSize - 8,
            imgSize,
            imgSize
          );
          ctx.shadowBlur = 0;
        } else {
          // Enhanced fallback display
          ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
          ctx.fillRect(player.x - 25, player.y - CONFIG.PLAYER_SIZE/2 - 30, 50, 24);
          ctx.strokeStyle = '#FFD700';
          ctx.lineWidth = 2;
          ctx.strokeRect(player.x - 25, player.y - CONFIG.PLAYER_SIZE/2 - 30, 50, 24);
          ctx.fillStyle = '#000';
          ctx.font = 'bold 12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(player.carrying.toUpperCase(), player.x, player.y - CONFIG.PLAYER_SIZE/2 - 12);
        }
      }
    }
    
    // Render customers (Phase 5 - Walking animation in customer area)
    function renderCustomers() {
      if (!game.currentCustomer || game.customerState === 'gone') return;
      
      // Render customer area background
      ctx.fillStyle = 'rgba(139, 69, 19, 0.3)'; // Brown customer area
      ctx.fillRect(KITCHEN.CUSTOMER_AREA.LEFT, KITCHEN.CUSTOMER_AREA.TOP, 
                   KITCHEN.CUSTOMER_AREA.RIGHT - KITCHEN.CUSTOMER_AREA.LEFT, 
                   KITCHEN.CUSTOMER_AREA.BOTTOM - KITCHEN.CUSTOMER_AREA.TOP);
      
      // Customer area border
      ctx.strokeStyle = '#8B4513';
      ctx.lineWidth = 2;
      ctx.strokeRect(KITCHEN.CUSTOMER_AREA.LEFT, KITCHEN.CUSTOMER_AREA.TOP, 
                     KITCHEN.CUSTOMER_AREA.RIGHT - KITCHEN.CUSTOMER_AREA.LEFT, 
                     KITCHEN.CUSTOMER_AREA.BOTTOM - KITCHEN.CUSTOMER_AREA.TOP);
      
      // Queue line indicator
      ctx.strokeStyle = '#654321';
      ctx.lineWidth = 3;
      ctx.setLineDash([10, 10]);
      ctx.beginPath();
      ctx.moveTo(KITCHEN.CUSTOMER_AREA.QUEUE_X, KITCHEN.CUSTOMER_AREA.TOP + 20);
      ctx.lineTo(KITCHEN.CUSTOMER_AREA.QUEUE_X, KITCHEN.CUSTOMER_AREA.BOTTOM - 20);
      ctx.stroke();
      ctx.setLineDash([]);
      
      const customerImg = ASSETS.customers[game.currentCustomer.id];
      const spriteSize = 80; // Optimized size
      
      if (customerImg && ASSETS.loaded) {
        // Draw customer sprite at animated position
        ctx.drawImage(
          customerImg,
          game.customerPosition.x - spriteSize/2,
          game.customerPosition.y - spriteSize/2,
          spriteSize,
          spriteSize
        );
        
        // Add glow effect if waiting
        if (game.customerState === 'waiting') {
          ctx.shadowColor = 'rgba(255, 215, 0, 0.6)';
          ctx.shadowBlur = 12;
          ctx.drawImage(
            customerImg,
            game.customerPosition.x - spriteSize/2,
            game.customerPosition.y - spriteSize/2,
            spriteSize,
            spriteSize
          );
          ctx.shadowBlur = 0;
        }
        
        // Customer name tag (only when waiting)
        if (game.customerState === 'waiting') {
          ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
          ctx.fillRect(game.customerPosition.x - 40, game.customerPosition.y + 50, 80, 20);
          ctx.fillStyle = '#FFD700';
          ctx.font = 'bold 12px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(game.currentCustomer.name, game.customerPosition.x, game.customerPosition.y + 63);
        }
        
        // Speech bubble (only when waiting and has message)
        if (game.customerState === 'waiting' && game.customerMessage && game.messageTimer > 0) {
          renderSpeechBubble(
            game.customerPosition.x,
            game.customerPosition.y - 60,
            game.customerMessage
          );
        }
      } else {
        // Fallback customer visualization
        ctx.fillStyle = '#8A2BE2';
        ctx.beginPath();
        ctx.arc(game.customerPosition.x, game.customerPosition.y, 30, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // Customer name
        ctx.fillStyle = 'white';
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(game.currentCustomer.name, game.customerPosition.x, game.customerPosition.y + 4);
      }
    }
    
    // Speech bubble helper
    function renderSpeechBubble(x, y, text) {
      const bubbleWidth = Math.max(200, text.length * 8);
      const bubbleHeight = 40;
      
      // Bubble background
      ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      
      // Bubble shape (with fallback for older browsers)
      ctx.beginPath();
      if (ctx.roundRect) {
        ctx.roundRect(x - bubbleWidth/2, y - bubbleHeight, bubbleWidth, bubbleHeight, 10);
      } else {
        // Fallback rectangle
        ctx.rect(x - bubbleWidth/2, y - bubbleHeight, bubbleWidth, bubbleHeight);
      }
      ctx.fill();
      ctx.stroke();
      
      // Bubble pointer
      ctx.beginPath();
      ctx.moveTo(x - 10, y);
      ctx.lineTo(x, y + 10);
      ctx.lineTo(x + 10, y);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      
      // Bubble text
      ctx.fillStyle = '#000';
      ctx.font = '14px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(`"${text}"`, x, y - bubbleHeight/2 + 5);
    }
    
    // Render UI
    function renderUI() {
      // Enhanced divine header background (Phase 5 - Better colors!)
      const gradient = ctx.createLinearGradient(0, 0, canvas.width, 100);
      gradient.addColorStop(0, 'rgba(184, 134, 11, 0.9)'); // Rich gold
      gradient.addColorStop(0.5, 'rgba(146, 64, 14, 0.9)'); // Bronze  
      gradient.addColorStop(1, 'rgba(120, 53, 15, 0.9)'); // Dark bronze
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, 100);
      
      // Add ornate border
      ctx.strokeStyle = '#D4AF37'; // Gold border
      ctx.lineWidth = 3;
      ctx.strokeRect(0, 0, canvas.width, 100);
      
      // Score with divine styling (top-right)
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 24px Arial';
      ctx.textAlign = 'right';
      ctx.strokeStyle = '#000';
      ctx.lineWidth = 2;
      ctx.strokeText(`‚ö° ${game.score}/${CONFIG.WIN_SCORE}`, canvas.width - 20, 35);
      ctx.fillText(`‚ö° ${game.score}/${CONFIG.WIN_SCORE}`, canvas.width - 20, 35);
      ctx.strokeText(`üèõÔ∏è Level ${game.level}`, canvas.width - 20, 60);
      ctx.fillText(`üèõÔ∏è Level ${game.level}`, canvas.width - 20, 60);
      
      // Enhanced timer (top-center) - Phase 4
      if (game.currentRiddle) {
        ctx.textAlign = 'center';
        ctx.font = 'bold 32px Arial';
        let timerColor;
        if (game.timer <= 5) {
          timerColor = '#FF4500';
        } else if (game.timer <= 10) {
          timerColor = '#FFA500';
        } else {
          timerColor = '#32CD32';
        }
        
        // Timer with glow effect
        ctx.fillStyle = timerColor;
        ctx.shadowColor = timerColor;
        ctx.shadowBlur = 10;
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.strokeText(`‚è±Ô∏è ${Math.ceil(game.timer)}s`, canvas.width/2, 40);
        ctx.fillText(`‚è±Ô∏è ${Math.ceil(game.timer)}s`, canvas.width/2, 40);
        ctx.shadowBlur = 0;
      }
      
      // Enhanced riddle display (below timer) - Phase 4
      if (game.currentRiddle) {
        ctx.fillStyle = '#FFFACD'; // Light goldenrod
        ctx.font = 'bold 20px Arial';
        ctx.textAlign = 'center';
        ctx.strokeStyle = '#8B4513';
        ctx.lineWidth = 1;
        ctx.strokeText(game.currentRiddle.text, canvas.width/2, 75);
        ctx.fillText(game.currentRiddle.text, canvas.width/2, 75);
      }
      
      // Customer and message - Phase 2
      if (game.currentCustomer) {
        ctx.fillStyle = '#FFD700';
        ctx.font = '16px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(game.currentCustomer.name, 20, 35);
        
        if (game.customerMessage && game.messageTimer > 0) {
          ctx.fillStyle = 'white';
          ctx.font = '14px Arial';
          ctx.fillText(`"${game.customerMessage}"`, 20, 55);
        }
      }
      
      // Debug zone info (if debug mode)
      if (game.debugMode) {
        ctx.fillStyle = '#0F0';
        ctx.font = '12px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`Zone: ${game.player.currentZone || 'none'}`, 20, 85);
        if (game.player.carrying) {
          ctx.fillText(`Carrying: ${game.player.carrying}`, 20, 105);
        }
      }
      
      // Plate contents (below table)
      if (game.plate.length > 0) {
        ctx.fillStyle = 'white';
        ctx.font = '14px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(`Plate: ${game.plate.join(', ')}`, 
                     KITCHEN.POSITIONS.TABLE.x, 
                     KITCHEN.POSITIONS.TABLE.y + 100);
      }
      
      // Toast message (center)
      if (game.toastMessage && game.toastTimer > 0) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        const width = ctx.measureText(game.toastMessage).width + 40;
        ctx.fillRect(canvas.width/2 - width/2, canvas.height/2 - 30, width, 60);
        
        ctx.fillStyle = 'white';
        ctx.font = '18px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(game.toastMessage, canvas.width/2, canvas.height/2);
      }
      
      // Controls (bottom)
      ctx.fillStyle = '#AAA';
      ctx.font = '12px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('WASD: Move | E: Pickup/Place | Q: Undo | X: Trash | Enter: Deliver | ~: Debug',
                   canvas.width/2, canvas.height - 10);
      
      // FPS counter (debug)
      if (game.debugMode) {
        ctx.fillStyle = '#0F0';
        ctx.font = '14px Arial';
        ctx.textAlign = 'left';
        ctx.fillText(`FPS: ${game.currentFPS}`, 20, canvas.height - 40);
      }
    }
    
    // Menu screen
    function renderMenu() {
      ctx.fillStyle = '#1a1a1a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 48px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('ORDER OF THE GODS', canvas.width/2, 200);
      
      ctx.fillStyle = 'white';
      ctx.font = '24px Arial';
      ctx.fillText('Phase 5 - Expanded World & Walking Customers', canvas.width/2, 280);
      ctx.fillText('Watch customers walk in, order, and leave! Larger map, better graphics!', canvas.width/2, 320);
      
      ctx.font = '32px Arial';
      ctx.fillText('Press ENTER to Start', canvas.width/2, 420);
      
      ctx.font = '16px Arial';
      ctx.fillStyle = '#AAA';
      ctx.fillText('WASD: Move | E: Pickup/Place | Q: Undo | X: Trash | Enter: Deliver', canvas.width/2, 480);
      ctx.fillText('Solve 30 riddles with enhanced visuals! Watch for customer sprites.', canvas.width/2, 510);
      
      // Check for enter key to start
      if (input.wasPressed('enter')) {
        startGame();
      }
    }
    
    // Win screen
    function renderWinScreen() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 64px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('PHASE 1 COMPLETE!', canvas.width/2, 250);
      
      ctx.fillStyle = 'white';
      ctx.font = '32px Arial';
      ctx.fillText(`Final Score: ${game.score} points`, canvas.width/2, 350);
      
      ctx.font = '24px Arial';
      ctx.fillText('Core mechanics working!', canvas.width/2, 420);
      
      ctx.font = '32px Arial';
      ctx.fillText('Press ENTER to Restart', canvas.width/2, 520);
      
      // Check for restart
      if (input.wasPressed('enter')) {
        location.reload(); // Simple restart
      }
    }
    
    // Pause overlay
    function renderPauseOverlay() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      ctx.fillStyle = 'white';
      ctx.font = 'bold 48px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('PAUSED', canvas.width/2, canvas.height/2);
      
      ctx.font = '24px Arial';
      ctx.fillText('Press ESC to Resume', canvas.width/2, canvas.height/2 + 50);
    }
    
    // Debug info
    function renderDebug() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
      ctx.fillRect(10, 100, 300, 200);
      
      ctx.fillStyle = '#0F0';
      ctx.font = '12px monospace';
      ctx.textAlign = 'left';
      
      const info = [
        `Player: (${Math.round(game.player.x)}, ${Math.round(game.player.y)})`,
        `Zone: ${game.player.currentZone || 'none'}`,
        `Carrying: ${game.player.carrying || 'none'}`,
        `Plate: [${game.plate.join(', ')}]`,
        `State: ${game.state}`,
        `Score: ${game.score}/${CONFIG.WIN_SCORE} (Level ${game.level})`,
        `Timer: ${game.timer ? game.timer.toFixed(1) + 's' : 'none'}`,
        `Riddle: ${game.currentRiddle ? game.currentRiddle.id : 'none'}`,
        `Type: ${game.currentRiddle ? game.currentRiddle.type : 'none'}`,
        `Customer: ${game.currentCustomer ? game.currentCustomer.name : 'none'}`,
        `FPS: ${game.currentFPS}`,
        '',
        'Debug Commands (Console):',
        'debug.nextRiddle()',
        'debug.solveRiddle()',
        'debug.skipToLevel(2/3)',
        'debug.addScore(10)'
      ];
      
      info.forEach((line, i) => {
        ctx.fillText(line, 15, 120 + i * 15);
      });
      
      // Show hitboxes if enabled
      if (game.showHitboxes) {
        // Table zone
        ctx.strokeStyle = 'lime';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(KITCHEN.POSITIONS.TABLE.x, KITCHEN.POSITIONS.TABLE.y,
                KITCHEN.ZONES.TABLE_RADIUS, 0, Math.PI * 2);
        ctx.stroke();
        
        // Trash zone
        ctx.beginPath();
        ctx.arc(KITCHEN.POSITIONS.TRASH.x, KITCHEN.POSITIONS.TRASH.y,
                KITCHEN.ZONES.TRASH_RADIUS, 0, Math.PI * 2);
        ctx.stroke();
        
        // Bin zones
        for (let pos of Object.values(KITCHEN.POSITIONS.BINS)) {
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, KITCHEN.ZONES.BIN_RADIUS, 0, Math.PI * 2);
          ctx.stroke();
        }
        
        // Counter zone
        const counter = KITCHEN.POSITIONS.COUNTER;
        ctx.strokeRect(counter.x - KITCHEN.ZONES.COUNTER_WIDTH/2,
                      counter.y - KITCHEN.ZONES.COUNTER_HEIGHT/2 - 30,
                      KITCHEN.ZONES.COUNTER_WIDTH,
                      KITCHEN.ZONES.COUNTER_HEIGHT + 60);
      }
    }
    
    // Main render function
    function render() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw based on game state
      if (game.state === 'menu') {
        renderMenu();
      } else if (game.state === 'playing' || game.state === 'paused') {
        renderKitchen();
        renderCustomers(); // Phase 3 - Render customer sprites
        renderPlayer();
        renderUI();
        if (game.state === 'paused') {
          renderPauseOverlay();
        }
      } else if (game.state === 'won') {
        renderWinScreen();
      }
      
      // Debug info
      if (game.debugMode) {
        renderDebug();
      }
    }
    
    // =============================================================================
    // GAME LOOP & UPDATE
    // =============================================================================
    
    // Main update function
    function update(deltaTime) {
      if (game.state !== 'playing') return;
      
      // Update timer (Phase 2)
      if (game.currentRiddle) {
        game.timer -= deltaTime / 1000;
        if (game.timer <= 0) {
          game.timer = 0;
          // Timeout!
          game.customerMessage = randomChoice(game.currentCustomer.timeout);
          game.messageTimer = 2000;
          showToast("Time's up!");
          console.log("TIMEOUT! Next riddle...");
          AUDIO.playTimeout(); // Phase 3 - Audio feedback
          game.plate = [];
          game.customerState = 'walking_out';
          setTimeout(() => nextRiddle(), 2500); // Give time for walking animation
        }
      }
      
      // Update player
      updatePlayer(deltaTime);
      
      // Update customer animation (Phase 5)
      updateCustomerAnimation(deltaTime);
      
      // Handle input
      if (input.wasPressed('e')) {
        handleInteraction();
      }
      
      if (input.wasPressed('q')) {
        handleUndo();
      }
      
      if (input.wasPressed('x')) {
        handleTrash();
      }
      
      if (input.wasPressed('enter')) {
        handleDelivery();
      }
      
      // Update timers
      if (game.toastTimer > 0) {
        game.toastTimer -= deltaTime;
      }
      if (game.messageTimer > 0) {
        game.messageTimer -= deltaTime;
      }
      if (game.deliveryDebounce > 0) {
        game.deliveryDebounce -= deltaTime;
      }
    }
    
    // FPS calculation
    function updateFPS(currentTime) {
      game.frameCount++;
      if (currentTime - game.lastFPSTime >= 1000) {
        game.currentFPS = game.frameCount;
        game.frameCount = 0;
        game.lastFPSTime = currentTime;
      }
    }
    
    // Main game loop
    function gameLoop(currentTime) {
      const deltaTime = currentTime - game.lastTime;
      game.lastTime = currentTime;
      
      // Update FPS
      updateFPS(currentTime);
      
      // Skip huge deltas (first frame, tab switch)
      if (deltaTime < 100) {
        update(deltaTime);
      }
      
      render();
      requestAnimationFrame(gameLoop);
    }
    
    // =============================================================================
    // GAME INITIALIZATION
    // =============================================================================
    
    // Start the game
    function startGame() {
      game.state = 'playing';
      game.score = 0;
      game.level = 1;
      game.timePerRiddle = CONFIG.LEVEL_1_TIME;
      game.plate = [];
      game.usedRiddles = [];
      game.customerIndex = 0;
      game.shuffledCustomers = shuffleCustomers(); // Randomize customer order each game
      game.player.carrying = null;
      
      // Get first riddle
      nextRiddle();
      
      console.log('üéÆ Phase 5 Game started! Expanded world with walking customers!');
      showToast("Phase 5 Active - Watch customers walk and explore the larger map!");
    }
    
    // Initialize everything
    async function init() {
      console.log('üèõÔ∏è Initializing Order of the Gods - Phase 5...');
      
      // Check for mobile/small screen
      if (window.innerWidth < 900) {
        document.querySelector('.mobile-warning').style.display = 'block';
        canvas.style.display = 'none';
        console.log('‚ùå Mobile device detected - game blocked');
        return;
      }
      
      // Load Phase 3 assets
      try {
        await loadAssets();
        console.log('üé® All assets loaded successfully!');
      } catch (error) {
        console.log('‚ö†Ô∏è Some assets failed to load, using fallbacks');
      }
      
      // Initialize input
      input.init();
      
      // Initialize audio system
      AUDIO.init();
      
      // Start at menu
      game.state = 'menu';
      
      // Debug commands (Phase 2)
      window.debug = {
        showState: () => console.log(game),
        addScore: (n) => { 
          game.score += n; 
          updateLevel();
          console.log(`Score: ${game.score}, Level: ${game.level}`); 
        },
        teleport: (x, y) => { 
          game.player.x = x; 
          game.player.y = y; 
          console.log(`Teleported to ${x}, ${y}`);
        },
        testCorners: () => {
          const corners = [
            { x: KITCHEN.BOUNDS.LEFT + 20, y: KITCHEN.BOUNDS.TOP + 20 },
            { x: KITCHEN.BOUNDS.RIGHT - 20, y: KITCHEN.BOUNDS.TOP + 20 },
            { x: KITCHEN.BOUNDS.LEFT + 20, y: KITCHEN.BOUNDS.BOTTOM - 20 },
            { x: KITCHEN.BOUNDS.RIGHT - 20, y: KITCHEN.BOUNDS.BOTTOM - 20 }
          ];
          
          let i = 0;
          const interval = setInterval(() => {
            if (i >= corners.length) {
              clearInterval(interval);
              debug.teleport(640, 360); // Return to center
              return;
            }
            debug.teleport(corners[i].x, corners[i].y);
            i++;
          }, 1000);
        },
        nextRiddle: () => { nextRiddle(); console.log('Skipped to next riddle'); },
        skipToLevel: (level) => {
          if (level === 2) debug.addScore(CONFIG.LEVEL_2_SCORE);
          else if (level === 3) debug.addScore(CONFIG.LEVEL_3_SCORE);
          else console.log('Level must be 2 or 3');
        },
        setTimer: (seconds) => { game.timer = seconds; console.log(`Timer set to ${seconds}s`); },
        solveRiddle: () => {
          if (!game.currentRiddle) return;
          // Auto-solve current riddle
          game.plate = [];
          if (game.currentRiddle.type === 'COUNT') {
            for (let [ingredient, count] of Object.entries(game.currentRiddle.counts)) {
              for (let i = 0; i < count; i++) {
                game.plate.push(ingredient);
              }
            }
          } else if (game.currentRiddle.type === 'SANDWICH') {
            game.plate = [...game.currentRiddle.sandwich];
          }
          console.log('Auto-solved riddle:', game.plate);
        },
        toggleAudio: () => { 
          AUDIO.enabled = !AUDIO.enabled; 
          console.log(`Audio ${AUDIO.enabled ? 'enabled' : 'disabled'}`);
        },
        win: () => { game.score = CONFIG.WIN_SCORE; game.state = 'won'; },
        start: () => startGame()
      };
      
      // Start game loop
      game.lastTime = performance.now();
      game.lastFPSTime = performance.now();
      requestAnimationFrame(gameLoop);
      
      console.log('‚úÖ Phase 5 initialized! Press ENTER to start.');
      console.log('üí° Debug commands: debug.nextRiddle(), debug.solveRiddle(), debug.toggleAudio(), etc.');
      console.log('üö∂ Phase 5 features: Walking customers, Expanded map, Customer animations!');
      console.log('üé® Enhanced graphics: Better sprites, Random customer order, No emojis in riddles!');
    }
    
    // Start when page loads
    window.addEventListener('load', init);
    
  </script>
</body>
</html>
